/* 
 * Forge SDK
 *
 * The Forge Platform contains an expanding collection of web service components that can be used with Autodesk cloud-based products or your own technologies. Take advantage of Autodesk’s expertise in design and engineering.
 *

 * Contact: forge.help@autodesk.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Newtonsoft.Json.Linq;
using Autodesk.Forge.Client;
using Autodesk.Forge.Model;
using System.Security.Cryptography;
using System.Net.Http;
using System.Diagnostics;
using System.IO;
using System.Net.Http.Headers;

namespace Autodesk.Forge {
	/// <summary>
	/// Represents a collection of functions to interact with the API endpoints
	/// </summary>
	public interface IObjectsApi : IApiAccessor {
		#region Synchronous Operations

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Copies an object to another object name in the same bucket.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="newObjName">URL-encoded Object key to use as the destination</param>
		/// <returns>ObjectDetails</returns>
		/*ObjectDetails*/
		dynamic CopyTo (string bucketKey, string objectName, string newObjName);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Copies an object to another object name in the same bucket.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="newObjName">URL-encoded Object key to use as the destination</param>
		/// <returns>ApiResponse of ObjectDetails</returns>
		ApiResponse</*ObjectDetails*/dynamic> CopyToWithHttpInfo (string bucketKey, string objectName, string newObjName);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// This endpoint creates a signed URL that can be used to download an object within the specified expiration time. Be aware that if the object the signed URL points to is deleted or expires before the signed URL expires, then the signed URL will no longer be valid. A successful call to this endpoint requires bucket owner access.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="postBucketsSigned">Body Structure</param>
		/// <param name="access">Access for signed resource Acceptable values: &#x60;read&#x60;, &#x60;write&#x60;, &#x60;readwrite&#x60;. Default value: &#x60;read&#x60;  (optional, default to read)</param>
		/// <param name="useCdn">If true, this will generate a CloudFront URL for the S3 object</param>
		/// <returns>PostObjectSigned</returns>
		/*PostObjectSigned*/
		dynamic CreateSignedResource (string bucketKey, string objectName, PostBucketsSigned postBucketsSigned, string access = null, bool useCdn = true);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// This endpoint creates a signed URL that can be used to download an object within the specified expiration time. Be aware that if the object the signed URL points to is deleted or expires before the signed URL expires, then the signed URL will no longer be valid. A successful call to this endpoint requires bucket owner access.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="postBucketsSigned">Body Structure</param>
		/// <param name="access">Access for signed resource Acceptable values: &#x60;read&#x60;, &#x60;write&#x60;, &#x60;readwrite&#x60;. Default value: &#x60;read&#x60;  (optional, default to read)</param>
		/// <param name="useCdn">If true, this will generate a CloudFront URL for the S3 object</param>
		/// <returns>ApiResponse of PostObjectSigned</returns>
		ApiResponse</*PostObjectSigned*/dynamic> CreateSignedResourceWithHttpInfo (string bucketKey, string objectName, PostBucketsSigned postBucketsSigned, string access = null, bool useCdn = true);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Deletes an object from the bucket.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <returns></returns>
		void DeleteObject (string bucketKey, string objectName);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Deletes an object from the bucket.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <returns>ApiResponse of Object(void)</returns>
		ApiResponse<Object> DeleteObjectWithHttpInfo (string bucketKey, string objectName);
		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Delete a signed URL. A successful call to this endpoint requires bucket owner access.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns></returns>
		void DeleteSignedResource (string id, string region = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Delete a signed URL. A successful call to this endpoint requires bucket owner access.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>ApiResponse of Object(void)</returns>
		ApiResponse<Object> DeleteSignedResourceWithHttpInfo (string id, string region = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Download an object.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <returns>System.IO.Stream</returns>
		/*System.IO.Stream*/
		dynamic GetObject (string bucketKey, string objectName, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Download an object.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <returns>ApiResponse of System.IO.Stream</returns>
		ApiResponse</*System.IO.Stream*/dynamic> GetObjectWithHttpInfo (string bucketKey, string objectName, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Returns object details in JSON format.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="with">Extra information in details; multiple uses are supported Acceptable values: &#x60;createdDate&#x60;, &#x60;lastAccessedDate&#x60;, &#x60;lastModifiedDate&#x60;  (optional)</param>
		/// <returns>ObjectFullDetails</returns>
		/*ObjectFullDetails*/
		dynamic GetObjectDetails (string bucketKey, string objectName, DateTime? ifModifiedSince = null, string with = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Returns object details in JSON format.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="with">Extra information in details; multiple uses are supported Acceptable values: &#x60;createdDate&#x60;, &#x60;lastAccessedDate&#x60;, &#x60;lastModifiedDate&#x60;  (optional)</param>
		/// <returns>ApiResponse of ObjectFullDetails</returns>
		ApiResponse</*ObjectFullDetails*/dynamic> GetObjectDetailsWithHttpInfo (string bucketKey, string objectName, DateTime? ifModifiedSince = null, string with = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// List objects in a bucket. It is only available to the bucket creator.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="limit">Limit to the response size, Acceptable values: 1-100 Default &#x3D; 10  (optional, default to 10)</param>
		/// <param name="beginsWith">Provides a way to filter the based on object key name (optional)</param>
		/// <param name="startAt">Key to use as an offset to continue pagination This is typically the last bucket key found in a preceding GET buckets response  (optional)</param>
		/// <returns>BucketObjects</returns>
		/*BucketObjects*/
		dynamic GetObjects (string bucketKey, int? limit = null, string beginsWith = null, string startAt = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// List objects in a bucket. It is only available to the bucket creator.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="limit">Limit to the response size, Acceptable values: 1-100 Default &#x3D; 10  (optional, default to 10)</param>
		/// <param name="beginsWith">Provides a way to filter the based on object key name (optional)</param>
		/// <param name="startAt">Key to use as an offset to continue pagination This is typically the last bucket key found in a preceding GET buckets response  (optional)</param>
		/// <returns>ApiResponse of BucketObjects</returns>
		ApiResponse</*BucketObjects*/dynamic> GetObjectsWithHttpInfo (string bucketKey, int? limit = null, string beginsWith = null, string startAt = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Download an object using a signed URL.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>System.IO.Stream</returns>
		/*System.IO.Stream*/
		dynamic GetSignedResource (string id, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null, string region = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Download an object using a signed URL.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>ApiResponse of System.IO.Stream</returns>
		ApiResponse</*System.IO.Stream*/dynamic> GetSignedResourceWithHttpInfo (string id, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null, string region = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// This endpoint returns status information about a resumable upload.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <returns></returns>
		void GetStatusBySessionId (string bucketKey, string objectName, string sessionId);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// This endpoint returns status information about a resumable upload.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <returns>ApiResponse of Object(void)</returns>
		ApiResponse<Object> GetStatusBySessionIdWithHttpInfo (string bucketKey, string objectName, string sessionId);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// This endpoint allows resumable uploads for large files in chunks.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ObjectDetails</returns>
		/*ObjectDetails*/
		dynamic UploadChunk (string bucketKey, string objectName, int? contentLength, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream");

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// This endpoint allows resumable uploads for large files in chunks.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ApiResponse of ObjectDetails</returns>
		ApiResponse</*ObjectDetails*/dynamic> UploadChunkWithHttpInfo (string bucketKey, string objectName, int? contentLength, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream");

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Upload an object. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination. 
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ObjectDetails</returns>
		/*ObjectDetails*/
		dynamic UploadObject (string bucketKey, string objectName, int? contentLength, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream");

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Upload an object. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination. 
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ApiResponse of ObjectDetails</returns>
		ApiResponse</*ObjectDetails*/dynamic> UploadObjectWithHttpInfo (string bucketKey, string objectName, int? contentLength, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream");

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Overwrite a existing object using a signed URL.  Conditions to call this operation:  Object is available Expiration period is valid Signed URL should be created with &#x60;write&#x60; or &#x60;readwrite&#x60; 
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ObjectDetails</returns>
		/*ObjectDetails*/
		dynamic UploadSignedResource (string id, int? contentLength, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string ifMatch = null, string contentType = "application/octet-stream");

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Overwrite a existing object using a signed URL.  Conditions to call this operation:  Object is available Expiration period is valid Signed URL should be created with &#x60;write&#x60; or &#x60;readwrite&#x60; 
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ApiResponse of ObjectDetails</returns>
		ApiResponse</*ObjectDetails*/dynamic> UploadSignedResourceWithHttpInfo (string id, int? contentLength, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string ifMatch = null, string contentType = "application/octet-stream");

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Resumable upload for signed URLs.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>ObjectDetails</returns>
		/*ObjectDetails*/
		dynamic UploadSignedResourcesChunk (string id, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string contentType = "application/octet-stream");

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Resumable upload for signed URLs.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>ApiResponse of ObjectDetails</returns>
		ApiResponse</*ObjectDetails*/dynamic> UploadSignedResourcesChunkWithHttpInfo (string id, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string contentType = "application/octet-stream");

        #endregion Synchronous Operations

        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Copies an object to another object name in the same bucket.
        /// </remarks>
        /// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucketKey">URL-encoded bucket key</param>
        /// <param name="objectName">URL-encoded object name</param>
        /// <param name="newObjName">URL-encoded Object key to use as the destination</param>
        /// <returns>Task of ObjectDetails</returns>
        [Obsolete]
        System.Threading.Tasks.Task</*ObjectDetails*/dynamic> CopyToAsync (string bucketKey, string objectName, string newObjName);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Copies an object to another object name in the same bucket.
        /// </remarks>
        /// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucketKey">URL-encoded bucket key</param>
        /// <param name="objectName">URL-encoded object name</param>
        /// <param name="newObjName">URL-encoded Object key to use as the destination</param>
        /// <returns>Task of ApiResponse (ObjectDetails)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse</*ObjectDetails*/dynamic>> CopyToAsyncWithHttpInfo (string bucketKey, string objectName, string newObjName);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// This endpoint creates a signed URL that can be used to download an object within the specified expiration time. Be aware that if the object the signed URL points to is deleted or expires before the signed URL expires, then the signed URL will no longer be valid. A successful call to this endpoint requires bucket owner access.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="postBucketsSigned">Body Structure</param>
		/// <param name="access">Access for signed resource Acceptable values: &#x60;read&#x60;, &#x60;write&#x60;, &#x60;readwrite&#x60;. Default value: &#x60;read&#x60;  (optional, default to read)</param>
		/// <param name="useCdn">If true, this will generate a CloudFront URL for the S3 object</param>
		/// <returns>Task of PostObjectSigned</returns>
		System.Threading.Tasks.Task</*PostObjectSigned*/dynamic> CreateSignedResourceAsync (string bucketKey, string objectName, PostBucketsSigned postBucketsSigned, string access = null, bool useCdn = true);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// This endpoint creates a signed URL that can be used to download an object within the specified expiration time. Be aware that if the object the signed URL points to is deleted or expires before the signed URL expires, then the signed URL will no longer be valid. A successful call to this endpoint requires bucket owner access.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="postBucketsSigned">Body Structure</param>
		/// <param name="access">Access for signed resource Acceptable values: &#x60;read&#x60;, &#x60;write&#x60;, &#x60;readwrite&#x60;. Default value: &#x60;read&#x60;  (optional, default to read)</param>
		/// <param name="useCdn">If true, this will generate a CloudFront URL for the S3 object</param>
		/// <returns>Task of ApiResponse (PostObjectSigned)</returns>
		System.Threading.Tasks.Task<ApiResponse</*PostObjectSigned*/dynamic>> CreateSignedResourceAsyncWithHttpInfo (string bucketKey, string objectName, PostBucketsSigned postBucketsSigned, string access = null, bool useCdn = true);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Deletes an object from the bucket.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <returns>Task of void</returns>
		System.Threading.Tasks.Task DeleteObjectAsync (string bucketKey, string objectName);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Deletes an object from the bucket.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <returns>Task of ApiResponse</returns>
		System.Threading.Tasks.Task<ApiResponse<Object>> DeleteObjectAsyncWithHttpInfo (string bucketKey, string objectName);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Delete a signed URL. A successful call to this endpoint requires bucket owner access.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of void</returns>
		System.Threading.Tasks.Task DeleteSignedResourceAsync (string id, string region = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Delete a signed URL. A successful call to this endpoint requires bucket owner access.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of ApiResponse</returns>
		System.Threading.Tasks.Task<ApiResponse<Object>> DeleteSignedResourceAsyncWithHttpInfo (string id, string region = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Download an object.
        /// </remarks>
        /// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucketKey">URL-encoded bucket key</param>
        /// <param name="objectName">URL-encoded object name</param>
        /// <param name="range">A range of bytes to download from the specified object. (optional)</param>
        /// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
        /// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
        /// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
        /// <returns>Task of System.IO.Stream</returns>
        [Obsolete]
        System.Threading.Tasks.Task</*System.IO.Stream*/dynamic> GetObjectAsync (string bucketKey, string objectName, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Download an object.
        /// </remarks>
        /// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucketKey">URL-encoded bucket key</param>
        /// <param name="objectName">URL-encoded object name</param>
        /// <param name="range">A range of bytes to download from the specified object. (optional)</param>
        /// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
        /// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
        /// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
        /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse</*System.IO.Stream*/dynamic>> GetObjectAsyncWithHttpInfo (string bucketKey, string objectName, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Returns object details in JSON format.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="with">Extra information in details; multiple uses are supported Acceptable values: &#x60;createdDate&#x60;, &#x60;lastAccessedDate&#x60;, &#x60;lastModifiedDate&#x60;  (optional)</param>
		/// <returns>Task of ObjectFullDetails</returns>
		System.Threading.Tasks.Task</*ObjectFullDetails*/dynamic> GetObjectDetailsAsync (string bucketKey, string objectName, DateTime? ifModifiedSince = null, string with = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Returns object details in JSON format.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="with">Extra information in details; multiple uses are supported Acceptable values: &#x60;createdDate&#x60;, &#x60;lastAccessedDate&#x60;, &#x60;lastModifiedDate&#x60;  (optional)</param>
		/// <returns>Task of ApiResponse (ObjectFullDetails)</returns>
		System.Threading.Tasks.Task<ApiResponse</*ObjectFullDetails*/dynamic>> GetObjectDetailsAsyncWithHttpInfo (string bucketKey, string objectName, DateTime? ifModifiedSince = null, string with = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// List objects in a bucket. It is only available to the bucket creator.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="limit">Limit to the response size, Acceptable values: 1-100 Default &#x3D; 10  (optional, default to 10)</param>
		/// <param name="beginsWith">Provides a way to filter the based on object key name (optional)</param>
		/// <param name="startAt">Key to use as an offset to continue pagination This is typically the last bucket key found in a preceding GET buckets response  (optional)</param>
		/// <returns>Task of BucketObjects</returns>
		System.Threading.Tasks.Task</*BucketObjects*/dynamic> GetObjectsAsync (string bucketKey, int? limit = null, string beginsWith = null, string startAt = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// List objects in a bucket. It is only available to the bucket creator.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="limit">Limit to the response size, Acceptable values: 1-100 Default &#x3D; 10  (optional, default to 10)</param>
		/// <param name="beginsWith">Provides a way to filter the based on object key name (optional)</param>
		/// <param name="startAt">Key to use as an offset to continue pagination This is typically the last bucket key found in a preceding GET buckets response  (optional)</param>
		/// <returns>Task of ApiResponse (BucketObjects)</returns>
		System.Threading.Tasks.Task<ApiResponse</*BucketObjects*/dynamic>> GetObjectsAsyncWithHttpInfo (string bucketKey, int? limit = null, string beginsWith = null, string startAt = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Download an object using a signed URL.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of System.IO.Stream</returns>
		System.Threading.Tasks.Task</*System.IO.Stream*/dynamic> GetSignedResourceAsync (string id, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null, string region = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Download an object using a signed URL.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of ApiResponse (System.IO.Stream)</returns>
		System.Threading.Tasks.Task<ApiResponse</*System.IO.Stream*/dynamic>> GetSignedResourceAsyncWithHttpInfo (string id, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null, string region = null);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// This endpoint returns status information about a resumable upload.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <returns>Task of void</returns>
		System.Threading.Tasks.Task GetStatusBySessionIdAsync (string bucketKey, string objectName, string sessionId);

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// This endpoint returns status information about a resumable upload.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <returns>Task of ApiResponse</returns>
		System.Threading.Tasks.Task<ApiResponse<Object>> GetStatusBySessionIdAsyncWithHttpInfo (string bucketKey, string objectName, string sessionId);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint allows resumable uploads for large files in chunks.
        /// </remarks>
        /// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucketKey">URL-encoded bucket key</param>
        /// <param name="objectName">URL-encoded object name</param>
        /// <param name="contentLength">Indicates the size of the request body.</param>
        /// <param name="contentRange">Byte range of a segment being uploaded</param>
        /// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
        /// <param name="body"></param>
        /// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
        /// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
        /// <returns>Task of ObjectDetails</returns>
        [Obsolete]
        System.Threading.Tasks.Task</*ObjectDetails*/dynamic> UploadChunkAsync (string bucketKey, string objectName, int? contentLength, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream");

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// This endpoint allows resumable uploads for large files in chunks.
        /// </remarks>
        /// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucketKey">URL-encoded bucket key</param>
        /// <param name="objectName">URL-encoded object name</param>
        /// <param name="contentLength">Indicates the size of the request body.</param>
        /// <param name="contentRange">Byte range of a segment being uploaded</param>
        /// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
        /// <param name="body"></param>
        /// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
        /// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
        /// <returns>Task of ApiResponse (ObjectDetails)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse</*ObjectDetails*/dynamic>> UploadChunkAsyncWithHttpInfo (string bucketKey, string objectName, int? contentLength, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream");

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Upload an object. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination. 
        /// </remarks>
        /// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucketKey">URL-encoded bucket key</param>
        /// <param name="objectName">URL-encoded object name</param>
        /// <param name="contentLength">Indicates the size of the request body.</param>
        /// <param name="body"></param>
        /// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
        /// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
        /// <returns>Task of ObjectDetails</returns>
        [Obsolete]
        System.Threading.Tasks.Task</*ObjectDetails*/dynamic> UploadObjectAsync (string bucketKey, string objectName, int? contentLength, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream");

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Upload an object. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination. 
        /// </remarks>
        /// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucketKey">URL-encoded bucket key</param>
        /// <param name="objectName">URL-encoded object name</param>
        /// <param name="contentLength">Indicates the size of the request body.</param>
        /// <param name="body"></param>
        /// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
        /// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
        /// <returns>Task of ApiResponse (ObjectDetails)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse</*ObjectDetails*/dynamic>> UploadObjectAsyncWithHttpInfo (string bucketKey, string objectName, int? contentLength, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream");

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Overwrite a existing object using a signed URL.  Conditions to call this operation:  Object is available Expiration period is valid Signed URL should be created with &#x60;write&#x60; or &#x60;readwrite&#x60; 
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>Task of ObjectDetails</returns>
		System.Threading.Tasks.Task</*ObjectDetails*/dynamic> UploadSignedResourceAsync (string id, int? contentLength, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string ifMatch = null, string contentType = "application/octet-stream");

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Overwrite a existing object using a signed URL.  Conditions to call this operation:  Object is available Expiration period is valid Signed URL should be created with &#x60;write&#x60; or &#x60;readwrite&#x60; 
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>Task of ApiResponse (ObjectDetails)</returns>
		System.Threading.Tasks.Task<ApiResponse</*ObjectDetails*/dynamic>> UploadSignedResourceAsyncWithHttpInfo (string id, int? contentLength, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string ifMatch = null, string contentType = "application/octet-stream");

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Resumable upload for signed URLs.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of ObjectDetails</returns>
		System.Threading.Tasks.Task</*ObjectDetails*/dynamic> UploadSignedResourcesChunkAsync (string id, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string contentType = "application/octet-stream");

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>
		/// Resumable upload for signed URLs.
		/// </remarks>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of ApiResponse (ObjectDetails)</returns>
		System.Threading.Tasks.Task<ApiResponse</*ObjectDetails*/dynamic>> UploadSignedResourcesChunkAsyncWithHttpInfo (string id, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string contentType = "application/octet-stream");

		/// summary>Returns a signed S3 URL.</summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.ifNoneMatch">{String=} If the value of this header matches the ETag of the object, an entity will not be returned from the server; 
		/// instead a 304 (not modified) response will be returned without any message-body.</param>
		/// <param name="opts.ifModifiedSince">{Date=} If the requested object has not been modified since the time specified in this field,
		/// an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message-body.</param>
		/// <param name="opts.responseContentType">{String=} Value of the Content-Type header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.responseContentDisposition">{String=} Value of the Content Disposition header the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.responseCacheControl">{String=} Value of the Cache-Control header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.publicResourceFallback">{Boolean=} Allows fallback to OSS signed URLs in case of unmerged resumable uploads.</param>
		/// <param name="opts.useCdn">{Boolean=true} Will generate a CloudFront URL for the S3 object.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3download-GET/</href>
		/// <returns>Task of ApiResponse (ObjectS3Download)</returns>
		System.Threading.Tasks.Task<dynamic> getS3DownloadURLAsync (string bucketKey, string objectKey, Dictionary<string, object> opts = null);

		/// summary>Returns a signed S3 URL.</summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.ifNoneMatch">{String=} If the value of this header matches the ETag of the object, an entity will not be returned from the server; 
		/// instead a 304 (not modified) response will be returned without any message-body.</param>
		/// <param name="opts.ifModifiedSince">{Date=} If the requested object has not been modified since the time specified in this field,
		/// an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message-body.</param>
		/// <param name="opts.responseContentType">{String=} Value of the Content-Type header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.responseContentDisposition">{String=} Value of the Content Disposition header the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.responseCacheControl">{String=} Value of the Cache-Control header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.publicResourceFallback">{Boolean=} Allows fallback to OSS signed URLs in case of unmerged resumable uploads.</param>
		/// <param name="opts.useCdn">{Boolean=true} Will generate a CloudFront URL for the S3 object.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3download-GET/</href>
		/// <returns>Task of ApiResponse (ObjectS3Download)</returns>
		System.Threading.Tasks.Task<ApiResponse<dynamic>> getS3DownloadURLAsyncWithHttpInfo (string bucketKey, string objectKey, Dictionary<string, object> opts = null);

		/// <summary>
		/// Gets one or more signed URLs to objects. The signed URLs can be used to download the objects directly from S3, skipping OSS servers.
		/// Be aware that expiration time for the signed URL(s) is just 60 seconds. So, a request to the URL(s) must begin within 60 seconds; the transfer
		/// of the data can exceed 60 seconds.
		/// A successful call to this endpoint requires bucket owner access.
		/// Note that resumable uploads store each chunk individually. After upload completes, an async process merges all the chunks and creates the 
		/// definitive OSS file. This async process can take time. If you request an S3 download URL before the async process completes, the response returns
		/// a map of S3 URLs, one per chunk where the key is the corresponding range bytes. In case you don't want multiple URLs in the response, you can use 
		/// OSS signed URL functionality , with the public-resource-fallback query parameter set to true.
		/// Note: While this endpoint does not support range headers, the returned URL(s) can be used for ranged downloads. This way, downloads can be 
		/// parallelized using multiple ranges for maximum speed.
		/// </summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter</param>
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} Object name to create a download S3 signed URL for</param>
		/// <param name="body.requests[].response-content-type">{String=} Value of the Content-Type header that the client expects to receive. 
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].response-content-disposition">{String=} Value of the Content Disposition header the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].response-cache-control">{String=} Value of the Cache-Control header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].IfcNonecMatch">{String=} The value of this attribute is compared to the ETAG of the object. 
		/// If they match, the response body will show the status of this item as "skipped" with the reason as "Not modified".</param>
		/// <param name="body.requests[].If-Modified-Since">{Date=} If the requested object has not been modified since the time specified in this attribute,
		/// the response body will show the status of this item as "skipped" with the reason as "Not modified".</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.publicResourceFallback">{Boolean=false } (public-resource-fallback) Allows fallback to OSS signed URLs in case of unmerged resumable uploads.</param>
		/// <param name="opts.useCdn">{Boolean=true} Will generate a CloudFront URL for the S3 object.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-batchsigneds3download-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		System.Threading.Tasks.Task<dynamic> getS3DownloadURLsAsync (string bucketKey, PostBatchSignedS3DownloadPayload body, Dictionary<string, object> opts = null);

		/// <summary>
		/// Gets one or more signed URLs to objects. The signed URLs can be used to download the objects directly from S3, skipping OSS servers.
		/// Be aware that expiration time for the signed URL(s) is just 60 seconds. So, a request to the URL(s) must begin within 60 seconds; the transfer
		/// of the data can exceed 60 seconds.
		/// A successful call to this endpoint requires bucket owner access.
		/// Note that resumable uploads store each chunk individually. After upload completes, an async process merges all the chunks and creates the 
		/// definitive OSS file. This async process can take time. If you request an S3 download URL before the async process completes, the response returns
		/// a map of S3 URLs, one per chunk where the key is the corresponding range bytes. In case you don't want multiple URLs in the response, you can use 
		/// OSS signed URL functionality , with the public-resource-fallback query parameter set to true.
		/// Note: While this endpoint does not support range headers, the returned URL(s) can be used for ranged downloads. This way, downloads can be 
		/// parallelized using multiple ranges for maximum speed.
		/// </summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter</param>
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} Object name to create a download S3 signed URL for</param>
		/// <param name="body.requests[].response-content-type">{String=} Value of the Content-Type header that the client expects to receive. 
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].response-content-disposition">{String=} Value of the Content Disposition header the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].response-cache-control">{String=} Value of the Cache-Control header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].If-None-Match">{String=} The value of this attribute is compared to the ETAG of the object. 
		/// If they match, the response body will show the status of this item as "skipped" with the reason as "Not modified".</param>
		/// <param name="body.requests[].If-Modified-Since">{Date=} If the requested object has not been modified since the time specified in this attribute,
		/// the response body will show the status of this item as "skipped" with the reason as "Not modified".</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.publicResourceFallback">{Boolean=false } (public-resource-fallback) Allows fallback to OSS signed URLs in case of unmerged resumable uploads.</param>
		/// <param name="opts.useCdn">{Boolean=true} Will generate a CloudFront URL for the S3 object.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-batchsigneds3download-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		System.Threading.Tasks.Task<ApiResponse<dynamic>> getS3DownloadURLsAsyncWithHttpInfo (string bucketKey, PostBatchSignedS3DownloadPayload body, Dictionary<string, object> opts = null);

		/// <summary>Requests an S3 signed URL with which to upload an object, or an array of signed URLs with which to upload an object in multiple parts.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.uploadKey">{String=} Get a new set of signed urls if the ones that were generated before have already expired and the user 
		/// still needs to upload some of them.</param>
		/// <param name="opts.firstParts" default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.</param>
		/// <param name="opts.parts: default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.
		/// </param>
		/// <param name="opts.useAcceleration">{Boolean=true} Whether or not to generate an accelerated signed URL (ie: URLs of 
		/// the form …s3-accelerate.amazonaws.com… vs …s3.amazonaws.com…).
		/// When not specified, defaults to true. Providing non-boolean values will result in a 400 error.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3upload-GET/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		System.Threading.Tasks.Task<dynamic> getS3UploadURLAsync (string bucketKey, string objectKey, Dictionary<string, object> opts = null);

		/// <summary>Requests an S3 signed URL with which to upload an object, or an array of signed URLs with which to upload an object in multiple parts.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.uploadKey">{String=} Get a new set of signed urls if the ones that were generated before have already expired and the user 
		/// still needs to upload some of them.</param>
		/// <param name="opts.firstParts" default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.</param>
		/// <param name="opts.parts: default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.
		/// </param>
		/// <param name="opts.useAcceleration">{Boolean=true} Whether or not to generate an accelerated signed URL (ie: URLs of 
		/// the form …s3-accelerate.amazonaws.com… vs …s3.amazonaws.com…).
		/// When not specified, defaults to true. Providing non-boolean values will result in a 400 error.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3upload-GET/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		System.Threading.Tasks.Task<ApiResponse<dynamic>> getS3UploadURLAsyncWithHttpInfo (string bucketKey, string objectKey, Dictionary<string, object> opts = null);

		/// <summary>Instructs OSS to complete the object creation process after the bytes have been uploaded directly to S3.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} </param>
		/// <param name="body.uploadKey">{String} The identifier of the upload session, which was provided by OSS in the response to the Get Upload URL/s request.</param>
		/// <param name="body.size">{Integer=} The expected size of the uploaded object. If provided, OSS will check this against the blob in S3 and return
		/// an error if the size does not match.</param>
		/// <param name="body.eTags">{List<String>=} An array of eTags. S3 returns an eTag to each upload request, be it for a chunk or an entire file.
		/// For a single-part upload, this array contains the expected eTag of the entire object. For a multipart upload, this array contains the expected 
		/// eTag of each part of the upload; the index of an eTag in the array corresponds to its part number in the upload. If provided, OSS will validate 
		/// these eTags against the content in S3, and return an error if the eTags do not match (indicating some form of data corruption).</param>
		/// <param name="opts">{Object=} Optional parameters
		/// <param name="opts.xAdsMetaContentType">{String=} (x-ads-meta-Content-Type) The Content-Type value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts.xAdsMetaContentDisposition">{String=} (x-ads-meta-Content-Disposition) The Content-Disposition value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts.xAdsMetaContentEncoding">{String=} (x-ads-meta-Content-Encoding) The Content-Encoding value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts.xAdsMetaCacheControl">{String=} (x-ads-meta-Cache-Control) The Cache-Control value that OSS will store in the record for the uploaded object.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3upload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		System.Threading.Tasks.Task<dynamic> completeS3UploadAsync (string bucketKey, string objectKey, PostCompleteS3UploadPayload body, Dictionary<string, object> opts = null);

		/// <summary>Instructs OSS to complete the object creation process after the bytes have been uploaded directly to S3.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} </param>
		/// <param name="body.uploadKey">{String} The identifier of the upload session, which was provided by OSS in the response to the Get Upload URL/s request.</param>
		/// <param name="body.size">{Integer=} The expected size of the uploaded object. If provided, OSS will check this against the blob in S3 and return
		/// an error if the size does not match.</param>
		/// <param name="body.eTags">{List<String>=} An array of eTags. S3 returns an eTag to each upload request, be it for a chunk or an entire file.
		/// For a single-part upload, this array contains the expected eTag of the entire object. For a multipart upload, this array contains the expected 
		/// eTag of each part of the upload; the index of an eTag in the array corresponds to its part number in the upload. If provided, OSS will validate 
		/// these eTags against the content in S3, and return an error if the eTags do not match (indicating some form of data corruption).</param>
		/// <param name="opts">{Object=} Optional parameters
		/// <param name="opts.xAdsMetaContentType">{String=} (x-ads-meta-Content-Type) The Content-Type value that OSS will store in the record for the uploaded obcreateject.</param>
		/// <param name="opts.xAdsMetaContentDisposition">{String=} (x-ads-meta-Content-Disposition) The Content-Disposition value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts.xAdsMetaContentEncoding">{String=} (x-ads-meta-Content-Encoding) The Content-Encoding value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts.xAdsMetaCacheControl">{String=} (x-ads-meta-Cache-Control) The Cache-Control value that OSS will store in the record for the uploaded object.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3upload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		System.Threading.Tasks.Task<ApiResponse<dynamic>> completeS3UploadAsyncWithHttpInfo (string bucketKey, string objectKey, PostCompleteS3UploadPayload body, Dictionary<string, object> opts = null);

		/// <summary>Instructs OSS to complete the object creation process for numerous objects after their bytes have been uploaded directly to S3.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} The key/name of the object for which to complete an upload.</param>
		/// <param name="body.requests[].uploadKey">{String} The identifier of the upload session, which was provided by OSS in the response to the Get Upload URL/s request.</param>
		/// <param name="body.requests[].size">{Integer=} The expected size of the uploaded object. If provided, OSS will check this against the blob in S3 and return
		/// an error if the size does not match.</param>
		/// <param name="body.requests[].eTags">{String[]=} An array of eTags. S3 returns an eTag to each upload request, be it for a chunk or an entire file.
		/// For a single-part upload, this array contains the expected eTag of the entire object. For a multipart upload, this array contains the expected 
		/// eTag of each part of the upload; the index of an eTag in the array corresponds to its part number in the upload. If provided, OSS will validate 
		/// these eTags against the content in S3, and return an error if the eTags do not match (indicating some form of data corruption).</param>
		/// <param name="body.requests[].xAdsMetaContentType">{String=} (x-ads-meta-Content-Type) The Content-Type value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaContentDisposition">{String=} (x-ads-meta-Content-Disposition) The Content-Disposition value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaContentEncoding">{String=} (x-ads-meta-Content-Encoding) The Content-Encoding value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaCacheControl">{String=} (x-ads-meta-Cache-Control) The Cache-Control value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-batchcompleteupload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		System.Threading.Tasks.Task<dynamic> completeS3UploadsAsync (string bucketKey, PostBatchCompleteS3UploadPayload body, Dictionary<string, object> opts = null);

		/// <summary>Instructs OSS to complete the object creation process for numerous objects after their bytes have been uploaded directly to S3.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} The key/name of the object for which to complete an upload.</param>
		/// <param name="body.requests[].uploadKey">{String} The identifier of the upload session, which was provided by OSS in the response to the Get Upload URL/s request.</param>
		/// <param name="body.requests[].size">{Integer=} The expected size of the uploaded object. If provided, OSS will check this against the blob in S3 and return
		/// an error if the size does not match.</param>
		/// <param name="body.requests[].eTags">{String[]=} An array of eTags. S3 returns an eTag to each upload request, be it for a chunk or an entire file.
		/// For a single-part upload, this array contains the expected eTag of the entire object. For a multipart upload, this array contains the expected 
		/// eTag of each part of the upload; the index of an eTag in the array corresponds to its part number in the upload. If provided, OSS will validate 
		/// these eTags against the content in S3, and return an error if the eTags do not match (indicating some form of data corruption).</param>
		/// <param name="body.requests[].xAdsMetaContentType">{String=} (x-ads-meta-Content-Type) The Content-Type value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaContentDisposition">{String=} (x-ads-meta-Content-Disposition) The Content-Disposition value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaContentEncoding">{String=} (x-ads-meta-Content-Encoding) The Content-Encoding value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaCacheControl">{String=} (x-ads-meta-Cache-Control) The Cache-Control value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-batchcompleteupload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		System.Threading.Tasks.Task<ApiResponse<dynamic>> completeS3UploadsAsyncWithHttpInfo (string bucketKey, PostBatchCompleteS3UploadPayload body, Dictionary<string, object> opts = null);

		/// <summary>Requests a batch of S3 signed URL with which to upload multiple objects or chunks of multiple objects.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter</param>
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} The key/name of the object for which to create an S3 upload URL. If neither the "part" nor "parts"
		/// attribute is provided, OSS will return a single upload URL with which to upload the entire object.</param>
		/// <param name="body.requests[].uploadKey">{String=} Get a new set of signed urls if the ones that were generated before have already expired and the user 
		/// still needs to upload some of them.</param>
		/// <param name="body.requests[].firstParts" default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.
		/// @param {Integer=} [body.requests[].parts=1] For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.useAcceleration">{Boolean=true} Whether or not to generate an accelerated signed URL (ie: URLs of
		/// the form …s3-accelerate.amazonaws.com… vs …s3.amazonaws.com…).
		/// When not specified, defaults to true. Providing non-boolean values will result in a 400 error.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-batchsigneds3upload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		System.Threading.Tasks.Task<dynamic> getS3UploadURLsAsync (string bucketKey, PostBatchSignedS3UploadPayload body, Dictionary<string, object> opts = null);

		/// <summary>Requests a batch of S3 signed URL with which to upload multiple objects or chunks of multiple objects.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter</param>
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} The key/name of the object for which to create an S3 upload URL. If neither the "part" nor "parts"
		/// attribute is provided, OSS will return a single upload URL with which to upload the entire object.</param>
		/// <param name="body.requests[].uploadKey">{String=} Get a new set of signed urls if the ones that were generated before have already expired and the user 
		/// still needs to upload some of them.</param>
		/// <param name="body.requests[].firstParts" default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.
		/// @param {Integer=} [body.requests[].parts=1] For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.useAcceleration">{Boolean=true} Whether or not to generate an accelerated signed URL (ie: URLs of
		/// the form …s3-accelerate.amazonaws.com… vs …s3.amazonaws.com…).
		/// When not specified, defaults to true. Providing non-boolean values will result in a 400 error.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-batchsigneds3upload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		System.Threading.Tasks.Task<ApiResponse<dynamic>> getS3UploadURLsAsyncWithHttpInfo (string bucketKey, PostBatchSignedS3UploadPayload body, Dictionary<string, object> opts = null);

		// Workflow implementations

		/// <summary>Download a resource.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objects">{Object|Object[]} Object or Object array of resource to uplaod with their parameters</param>
		/// <param name="object[].objectKey">{String} object key</param>
		/// <param name="object[].responseType">{String} Resource to upload
		/// If String, it is the expected response type (defaults to json) ['arraybuffer', 'document', 'json', 'text', 'stream']
		/// If you 'stream', you need to provide a writable stream ('data'), the method will pipe content into it.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.publicResourceFallback">{Boolean=false} Allows fallback to OSS signed URLs in case of unmerged resumable uploads.</param>
		/// <param name="opts.useCdn">{Boolean=true} Will generate a CloudFront URL for the S3 object.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <param name="opts.chunkSize">{Integer=0} Chunk size in Mb. Should not be below 5Mb. Default is 0, download file in one piece.</param>
		/// <param name="onDownloadProgress">{DownloadItemsCallBack} (progressEvent) => {}</param>
		/// <param name="onRefreshToken">{RefreshTokenCallBack} () => {}</param>
		/// <returns>Task of ApiResponse (dynamic[])</returns>
		System.Threading.Tasks.Task<List<DownloadItemDesc>> downloadResources (string bucketKey, List<DownloadItemDesc> objects, Dictionary<string, object> opts = null, DownloadItemsCallBack onDownloadProgress = null, RefreshTokenCallBack onRefreshToken = null);

		/// <summary>Upload a resource. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objects">{Object|Object[]} Object or Object array of resource to upload with their parameters</param>
		/// <param name="object[].objectKey">{String} object key</param>
		/// <param name="object[].data">{String|Buffer|Stream} Resource to upload (String| Buffer | Stream)</param>
		/// <param name="object[].eTags">{String[]=} An array of eTags. S3 returns an eTag to each upload request, be it for a chunk or an entire file.
		/// For a single-part upload, this array contains the expected eTag of the entire object. For a multipart upload, this array contains the expected 
		/// eTag of each part of the upload; the index of an eTag in the array corresponds to its part number in the upload. If provided, OSS will validate 
		/// these eTags against the content in S3, and return an error if the eTags do not match (indicating some form of data corruption).</param>
		/// <param name="object[].xAdsMetaContentType">{String=} (x-ads-meta-Content-Type) The Content-Type value that OSS will store in the record for the uploaded object.</param>
		/// <param name="object[].xAdsMetaContentDisposition">{String=} (x-ads-meta-Content-Disposition) The Content-Disposition value that OSS will store in the record for the uploaded object.</param>
		/// <param name="object[].xAdsMetaContentEncoding">{String=} (x-ads-meta-Content-Encoding) The Content-Encoding value that OSS will store in the record for the uploaded object.</param>
		/// <param name="object[].xAdsMetaCacheControl">{String=} (x-ads-meta-Cache-Control) The Cache-Control value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="chunkSize">{Integer=5} Chunk size in Mb. Should not be below 5Mb.</param>
		/// <param name="maxBatches">{Integer=25} Maximum batch to produces. Should not be above 25 or below 1.</param>
		/// <param name="opts.useAcceleration">{Boolean=true} Whether or not to generate an accelerated signed URL (ie: URLs of 
		/// the form …s3-accelerate.amazonaws.com… vs …s3.amazonaws.com…).
		/// When not specified, defaults to true. Providing non-boolean values will result in a 400 error.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <param name="onDownloadProgress">{DownloadItemsCallBack} (progressEvent) => {}</param>
		/// <param name="onRefreshToken">{RefreshTokenCallBack} () => {}</param>
		/// <returns>Task of ApiResponse (dynamic[])</returns>
		System.Threading.Tasks.Task<List<UploadItemDesc>> uploadResources (string bucketKey, List<UploadItemDesc> objects, Dictionary<string, object> opts = null, UploadItemsCallBack onUploadProgress = null, RefreshTokenCallBack onRefreshToken = null);

		// Workflow implementations

		#endregion Asynchronous Operations

	}

	/// <summary>
	/// Represents a collection of functions to interact with the API endpoints
	/// </summary>
	public partial class ObjectsApi : IObjectsApi {

		private Autodesk.Forge.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

		/// <summary>
		/// Initializes a new instance of the <see cref="ObjectsApi"/> class.
		/// </summary>
		/// <returns></returns>
		public ObjectsApi (String basePath) {
			this.Configuration = new Configuration (new ApiClient (basePath));

			ExceptionFactory = Autodesk.Forge.Client.Configuration.DefaultExceptionFactory;

			// ensure API client has configuration ready
			if ( Configuration.ApiClient.Configuration == null ) {
				this.Configuration.ApiClient.Configuration = this.Configuration;
			}
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="ObjectsApi"/> class
		/// using Configuration object
		/// </summary>
		/// <param name="configuration">An instance of Configuration</param>
		/// <returns></returns>
		public ObjectsApi (Configuration configuration = null) {
			if ( configuration == null ) // use the default one in Configuration
				this.Configuration = Configuration.Default;
			else
				this.Configuration = configuration;

			ExceptionFactory = Autodesk.Forge.Client.Configuration.DefaultExceptionFactory;

			// ensure API client has configuration ready
			if ( Configuration.ApiClient.Configuration == null ) {
				this.Configuration.ApiClient.Configuration = this.Configuration;
			}
		}

		/// <summary>
		/// Gets the base path of the API client.
		/// </summary>
		/// <value>The base path</value>
		public String GetBasePath () {
			return this.Configuration.ApiClient.RestClient.Options.BaseUrl.ToString ();
		}

		/// <summary>
		/// Sets the base path of the API client.
		/// </summary>
		/// <value>The base path</value>
		[Obsolete ("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
		public void SetBasePath (String basePath) {
			// do nothing
		}

		/// <summary>
		/// Gets or sets the configuration object
		/// </summary>
		/// <value>An instance of the Configuration</value>
		public Configuration Configuration { get; set; }

		/// <summary>
		/// Provides a factory method hook for the creation of exceptions.
		/// </summary>
		public Autodesk.Forge.Client.ExceptionFactory ExceptionFactory {
			get {
				if ( _exceptionFactory != null && _exceptionFactory.GetInvocationList ().Length > 1 ) {
					throw new InvalidOperationException ("Multicast delegate for ExceptionFactory is unsupported.");
				}
				return _exceptionFactory;
			}
			set { _exceptionFactory = value; }
		}

		/// <summary>
		/// Gets the default header.
		/// </summary>
		/// <returns>Dictionary of HTTP header</returns>
		[Obsolete ("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
		public Dictionary<string, string> DefaultHeader () {
			return this.Configuration.DefaultHeader;
		}

		/// <summary>
		/// Add default header.
		/// </summary>
		/// <param name="key">Header field name.</param>
		/// <param name="value">Header field value.</param>
		/// <returns></returns>
		[Obsolete ("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
		public void AddDefaultHeader (string key, string value) {
			this.Configuration.AddDefaultHeader (key, value);
		}

		/// <summary>
		///  Copies an object to another object name in the same bucket.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="newObjName">URL-encoded Object key to use as the destination</param>
		/// <returns>ObjectDetails</returns>
		public /*ObjectDetails*/dynamic CopyTo (string bucketKey, string objectName, string newObjName) {
			ApiResponse</*ObjectDetails*/dynamic> localVarResponse = CopyToWithHttpInfo (bucketKey, objectName, newObjName);
			return localVarResponse.Data;
		}

		/// <summary>
		///  Copies an object to another object name in the same bucket.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="newObjName">URL-encoded Object key to use as the destination</param>
		/// <returns>ApiResponse of ObjectDetails</returns>
		public ApiResponse< /*ObjectDetails*/dynamic> CopyToWithHttpInfo (string bucketKey, string objectName, string newObjName) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->CopyTo");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->CopyTo");
			// verify the required parameter 'newObjName' is set
			if ( newObjName == null )
				throw new ApiException (400, "Missing required parameter 'newObjName' when calling ObjectsApi->CopyTo");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}/copyto/{newObjName}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( newObjName != null )
				localVarPathParams.Add ("newObjName", Configuration.ApiClient.ParameterToString (newObjName)); // path parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Put, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("CopyTo", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectDetails)));

		}

		/// <summary>
		///  Copies an object to another object name in the same bucket.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="newObjName">URL-encoded Object key to use as the destination</param>
		/// <returns>Task of ObjectDetails</returns>
		public async System.Threading.Tasks.Task</*ObjectDetails*/dynamic> CopyToAsync (string bucketKey, string objectName, string newObjName) {
			ApiResponse</*ObjectDetails*/dynamic> localVarResponse = await CopyToAsyncWithHttpInfo (bucketKey, objectName, newObjName);
			return localVarResponse.Data;

		}

		/// <summary>
		///  Copies an object to another object name in the same bucket.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="newObjName">URL-encoded Object key to use as the destination</param>
		/// <returns>Task of ApiResponse (ObjectDetails)</returns>
		public async System.Threading.Tasks.Task<ApiResponse</*ObjectDetails*/dynamic>> CopyToAsyncWithHttpInfo (string bucketKey, string objectName, string newObjName) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->CopyTo");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->CopyTo");
			// verify the required parameter 'newObjName' is set
			if ( newObjName == null )
				throw new ApiException (400, "Missing required parameter 'newObjName' when calling ObjectsApi->CopyTo");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}/copyto/{newObjName}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( newObjName != null )
				localVarPathParams.Add ("newObjName", Configuration.ApiClient.ParameterToString (newObjName)); // path parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Put, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("CopyTo", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectDetails)));

		}

		/// <summary>
		///  This endpoint creates a signed URL that can be used to download an object within the specified expiration time. Be aware that if the object the signed URL points to is deleted or expires before the signed URL expires, then the signed URL will no longer be valid. A successful call to this endpoint requires bucket owner access.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="postBucketsSigned">Body Structure</param>
		/// <param name="access">Access for signed resource Acceptable values: &#x60;read&#x60;, &#x60;write&#x60;, &#x60;readwrite&#x60;. Default value: &#x60;read&#x60;  (optional, default to read)</param>
		/// <param name="useCdn">If true, this will generate a CloudFront URL for the S3 object</param>
		/// <returns>PostObjectSigned</returns>
		public /*PostObjectSigned*/dynamic CreateSignedResource (string bucketKey, string objectName, PostBucketsSigned postBucketsSigned, string access = null, bool useCdn = true) {
			ApiResponse</*PostObjectSigned*/dynamic> localVarResponse = CreateSignedResourceWithHttpInfo (bucketKey, objectName, postBucketsSigned, access, useCdn);
			return (localVarResponse.Data);
		}

		/// <summary>
		///  This endpoint creates a signed URL that can be used to download an object within the specified expiration time. Be aware that if the object the signed URL points to is deleted or expires before the signed URL expires, then the signed URL will no longer be valid. A successful call to this endpoint requires bucket owner access.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="postBucketsSigned">Body Structure</param>
		/// <param name="access">Access for signed resource Acceptable values: &#x60;read&#x60;, &#x60;write&#x60;, &#x60;readwrite&#x60;. Default value: &#x60;read&#x60;  (optional, default to read)</param>
		/// <param name="useCdn">If true, this will generate a CloudFront URL for the S3 object</param>
		/// <returns>ApiResponse of PostObjectSigned</returns>
		public ApiResponse< /*PostObjectSigned*/dynamic> CreateSignedResourceWithHttpInfo (string bucketKey, string objectName, PostBucketsSigned postBucketsSigned, string access = null, bool useCdn = true) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->CreateSignedResource");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->CreateSignedResource");
			// verify the required parameter 'postBucketsSigned' is set
			if ( postBucketsSigned == null )
				throw new ApiException (400, "Missing required parameter 'postBucketsSigned' when calling ObjectsApi->CreateSignedResource");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}/signed";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( access != null )
				localVarQueryParams.Add ("access", Configuration.ApiClient.ParameterToString (access)); // query parameter
			localVarQueryParams.Add ("useCdn", Configuration.ApiClient.ParameterToString (useCdn));
			if ( postBucketsSigned != null && postBucketsSigned.GetType () == typeof (byte []) ) // http body (model) parameter
			{
				localVarPostBody = postBucketsSigned; // byte array
			} else if ( postBucketsSigned != null
					   && (postBucketsSigned.GetType () == typeof (System.IO.FileStream)
						   || postBucketsSigned.GetType () == typeof (System.IO.BinaryReader)
						   || postBucketsSigned.GetType () == typeof (System.IO.BufferedStream)
						   || postBucketsSigned.GetType () == typeof (System.IO.MemoryStream)
						   || postBucketsSigned.GetType () == typeof (System.IO.StreamReader)
						  )
					  ) {
				localVarPostBody = Configuration.ApiClient.toByteArray (postBucketsSigned); // byte array
			} else if ( postBucketsSigned != null ) {
				localVarPostBody = Configuration.ApiClient.Serialize (postBucketsSigned);
			}

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Post, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("CreateSignedResource", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*PostObjectSigned*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(PostObjectSigned)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (PostObjectSigned)));

		}

		/// <summary>
		///  This endpoint creates a signed URL that can be used to download an object within the specified expiration time. Be aware that if the object the signed URL points to is deleted or expires before the signed URL expires, then the signed URL will no longer be valid. A successful call to this endpoint requires bucket owner access.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="postBucketsSigned">Body Structure</param>
		/// <param name="access">Access for signed resource Acceptable values: &#x60;read&#x60;, &#x60;write&#x60;, &#x60;readwrite&#x60;. Default value: &#x60;read&#x60;  (optional, default to read)</param>
		/// <param name="useCdn">If true, this will generate a CloudFront URL for the S3 object</param>
		/// <returns>Task of PostObjectSigned</returns>
		public async System.Threading.Tasks.Task</*PostObjectSigned*/dynamic> CreateSignedResourceAsync (string bucketKey, string objectName, PostBucketsSigned postBucketsSigned, string access = null, bool useCdn = true) {
			ApiResponse</*PostObjectSigned*/dynamic> localVarResponse = await CreateSignedResourceAsyncWithHttpInfo (bucketKey, objectName, postBucketsSigned, access, useCdn);
			return (localVarResponse.Data);
		}

		/// <summary>
		///  This endpoint creates a signed URL that can be used to download an object within the specified expiration time. Be aware that if the object the signed URL points to is deleted or expires before the signed URL expires, then the signed URL will no longer be valid. A successful call to this endpoint requires bucket owner access.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="postBucketsSigned">Body Structure</param>
		/// <param name="access">Access for signed resource Acceptable values: &#x60;read&#x60;, &#x60;write&#x60;, &#x60;readwrite&#x60;. Default value: &#x60;read&#x60;  (optional, default to read)</param>
		/// <param name="useCdn">If true, this will generate a CloudFront URL for the S3 object</param>
		/// <returns>Task of ApiResponse (PostObjectSigned)</returns>
		public async System.Threading.Tasks.Task<ApiResponse</*PostObjectSigned*/dynamic>> CreateSignedResourceAsyncWithHttpInfo (string bucketKey, string objectName, PostBucketsSigned postBucketsSigned, string access = null, bool useCdn = true) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->CreateSignedResource");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->CreateSignedResource");
			// verify the required parameter 'postBucketsSigned' is set
			if ( postBucketsSigned == null )
				throw new ApiException (400, "Missing required parameter 'postBucketsSigned' when calling ObjectsApi->CreateSignedResource");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}/signed";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( access != null )
				localVarQueryParams.Add ("access", Configuration.ApiClient.ParameterToString (access)); // query parameter
			localVarQueryParams.Add ("useCdn", Configuration.ApiClient.ParameterToString (useCdn));
			if ( postBucketsSigned != null && postBucketsSigned.GetType () == typeof (byte []) ) // http body (model) parameter
			{
				localVarPostBody = postBucketsSigned; // byte array
			} else if ( postBucketsSigned != null
					   && (postBucketsSigned.GetType () == typeof (System.IO.FileStream)
						   || postBucketsSigned.GetType () == typeof (System.IO.BinaryReader)
						   || postBucketsSigned.GetType () == typeof (System.IO.BufferedStream)
						   || postBucketsSigned.GetType () == typeof (System.IO.MemoryStream)
						   || postBucketsSigned.GetType () == typeof (System.IO.StreamReader)
						  )
					  ) {
				localVarPostBody = Configuration.ApiClient.toByteArray (postBucketsSigned); // byte array
			} else if ( postBucketsSigned != null ) {
				localVarPostBody = Configuration.ApiClient.Serialize (postBucketsSigned);
			}

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Post, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("CreateSignedResource", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*PostObjectSigned*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(PostObjectSigned)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (PostObjectSigned)));

		}

		/// <summary>
		///  Deletes an object from the bucket.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <returns></returns>
		public void DeleteObject (string bucketKey, string objectName) {
			DeleteObjectWithHttpInfo (bucketKey, objectName);
		}

		/// <summary>
		///  Deletes an object from the bucket.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <returns>ApiResponse of Object(void)</returns>
		public ApiResponse<Object> DeleteObjectWithHttpInfo (string bucketKey, string objectName) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->DeleteObject");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->DeleteObject");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Delete, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("DeleteObject", localVarResponse);
				if ( exception != null )
					throw exception;
			}


			return new ApiResponse<Object> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				null);
		}

		/// <summary>
		///  Deletes an object from the bucket.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <returns>Task of void</returns>
		public async System.Threading.Tasks.Task DeleteObjectAsync (string bucketKey, string objectName) {
			await DeleteObjectAsyncWithHttpInfo (bucketKey, objectName);

		}

		/// <summary>
		///  Deletes an object from the bucket.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <returns>Task of ApiResponse</returns>
		public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteObjectAsyncWithHttpInfo (string bucketKey, string objectName) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->DeleteObject");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->DeleteObject");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Delete, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("DeleteObject", localVarResponse);
				if ( exception != null )
					throw exception;
			}


			return new ApiResponse<Object> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				null);
		}

		/// <summary>
		///  Delete a signed URL. A successful call to this endpoint requires bucket owner access.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns></returns>
		public void DeleteSignedResource (string id, string region = null) {
			DeleteSignedResourceWithHttpInfo (id, region);
		}

		/// <summary>
		///  Delete a signed URL. A successful call to this endpoint requires bucket owner access.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>ApiResponse of Object(void)</returns>
		public ApiResponse<Object> DeleteSignedResourceWithHttpInfo (string id, string region = null) {
			// verify the required parameter 'id' is set
			if ( id == null )
				throw new ApiException (400, "Missing required parameter 'id' when calling ObjectsApi->DeleteSignedResource");

			var localVarPath = "/oss/v2/signedresources/{id}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"text/plain"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( id != null )
				localVarPathParams.Add ("id", Configuration.ApiClient.ParameterToString (id)); // path parameter
			if ( region != null )
				localVarQueryParams.Add ("region", Configuration.ApiClient.ParameterToString (region)); // query parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Delete, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("DeleteSignedResource", localVarResponse);
				if ( exception != null )
					throw exception;
			}


			return new ApiResponse<Object> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				null);
		}

		/// <summary>
		///  Delete a signed URL. A successful call to this endpoint requires bucket owner access.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of void</returns>
		public async System.Threading.Tasks.Task DeleteSignedResourceAsync (string id, string region = null) {
			await DeleteSignedResourceAsyncWithHttpInfo (id, region);

		}

		/// <summary>
		///  Delete a signed URL. A successful call to this endpoint requires bucket owner access.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of ApiResponse</returns>
		public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteSignedResourceAsyncWithHttpInfo (string id, string region = null) {
			// verify the required parameter 'id' is set
			if ( id == null )
				throw new ApiException (400, "Missing required parameter 'id' when calling ObjectsApi->DeleteSignedResource");

			var localVarPath = "/oss/v2/signedresources/{id}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"text/plain"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( id != null )
				localVarPathParams.Add ("id", Configuration.ApiClient.ParameterToString (id)); // path parameter
			if ( region != null )
				localVarQueryParams.Add ("region", Configuration.ApiClient.ParameterToString (region)); // query parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Delete, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("DeleteSignedResource", localVarResponse);
				if ( exception != null )
					throw exception;
			}


			return new ApiResponse<Object> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				null);
		}

		/// <summary>
		///  Download an object.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <returns>System.IO.Stream</returns>
		public /*System.IO.Stream*/dynamic GetObject (string bucketKey, string objectName, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null) {
			ApiResponse</*System.IO.Stream*/dynamic> localVarResponse = GetObjectWithHttpInfo (bucketKey, objectName, range, ifNoneMatch, ifModifiedSince, acceptEncoding);
			return localVarResponse.Data;
		}

		/// <summary>
		///  Download an object.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <returns>ApiResponse of System.IO.Stream</returns>
		public ApiResponse< /*System.IO.Stream*/dynamic> GetObjectWithHttpInfo (string bucketKey, string objectName, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->GetObject");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->GetObject");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/octet-stream"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( range != null )
				localVarHeaderParams.Add ("Range", Configuration.ApiClient.ParameterToString (range)); // header parameter
			if ( ifNoneMatch != null )
				localVarHeaderParams.Add ("If-None-Match", Configuration.ApiClient.ParameterToString (ifNoneMatch)); // header parameter
			if ( ifModifiedSince != null )
				localVarHeaderParams.Add ("If-Modified-Since", Configuration.ApiClient.ParameterToString (ifModifiedSince)); // header parameter
			if ( acceptEncoding != null )
				localVarHeaderParams.Add ("Accept-Encoding", Configuration.ApiClient.ParameterToString (acceptEncoding)); // header parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Get, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("GetObject", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*System.IO.Stream*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(System.IO.Stream)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (System.IO.Stream)));

		}

		/// <summary>
		///  Download an object.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <returns>Task of System.IO.Stream</returns>
		public async System.Threading.Tasks.Task</*System.IO.Stream*/dynamic> GetObjectAsync (string bucketKey, string objectName, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null) {
			ApiResponse</*System.IO.Stream*/dynamic> localVarResponse = await GetObjectAsyncWithHttpInfo (bucketKey, objectName, range, ifNoneMatch, ifModifiedSince, acceptEncoding);
			return localVarResponse.Data;

		}

		/// <summary>
		///  Download an object.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <returns>Task of ApiResponse (System.IO.Stream)</returns>
		public async System.Threading.Tasks.Task<ApiResponse</*System.IO.Stream*/dynamic>> GetObjectAsyncWithHttpInfo (string bucketKey, string objectName, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->GetObject");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->GetObject");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/octet-stream"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( range != null )
				localVarHeaderParams.Add ("Range", Configuration.ApiClient.ParameterToString (range)); // header parameter
			if ( ifNoneMatch != null )
				localVarHeaderParams.Add ("If-None-Match", Configuration.ApiClient.ParameterToString (ifNoneMatch)); // header parameter
			if ( ifModifiedSince != null )
				localVarHeaderParams.Add ("If-Modified-Since", Configuration.ApiClient.ParameterToString (ifModifiedSince)); // header parameter
			if ( acceptEncoding != null )
				localVarHeaderParams.Add ("Accept-Encoding", Configuration.ApiClient.ParameterToString (acceptEncoding)); // header parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Get, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("GetObject", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*System.IO.Stream*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(System.IO.Stream)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (System.IO.Stream)));

		}

		/// <summary>
		///  Returns object details in JSON format.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="with">Extra information in details; multiple uses are supported Acceptable values: &#x60;createdDate&#x60;, &#x60;lastAccessedDate&#x60;, &#x60;lastModifiedDate&#x60;  (optional)</param>
		/// <returns>ObjectFullDetails</returns>
		public /*ObjectFullDetails*/dynamic GetObjectDetails (string bucketKey, string objectName, DateTime? ifModifiedSince = null, string with = null) {
			ApiResponse</*ObjectFullDetails*/dynamic> localVarResponse = GetObjectDetailsWithHttpInfo (bucketKey, objectName, ifModifiedSince, with);
			return localVarResponse.Data;
		}

		/// <summary>
		///  Returns object details in JSON format.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="with">Extra information in details; multiple uses are supported Acceptable values: &#x60;createdDate&#x60;, &#x60;lastAccessedDate&#x60;, &#x60;lastModifiedDate&#x60;  (optional)</param>
		/// <returns>ApiResponse of ObjectFullDetails</returns>
		public ApiResponse< /*ObjectFullDetails*/dynamic> GetObjectDetailsWithHttpInfo (string bucketKey, string objectName, DateTime? ifModifiedSince = null, string with = null) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->GetObjectDetails");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->GetObjectDetails");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}/details";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( with != null )
				localVarQueryParams.Add ("with", Configuration.ApiClient.ParameterToString (with)); // query parameter
			if ( ifModifiedSince != null )
				localVarHeaderParams.Add ("If-Modified-Since", Configuration.ApiClient.ParameterToString (ifModifiedSince)); // header parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Get, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("GetObjectDetails", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectFullDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectFullDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectFullDetails)));

		}

		/// <summary>
		///  Returns object details in JSON format.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="with">Extra information in details; multiple uses are supported Acceptable values: &#x60;createdDate&#x60;, &#x60;lastAccessedDate&#x60;, &#x60;lastModifiedDate&#x60;  (optional)</param>
		/// <returns>Task of ObjectFullDetails</returns>
		public async System.Threading.Tasks.Task</*ObjectFullDetails*/dynamic> GetObjectDetailsAsync (string bucketKey, string objectName, DateTime? ifModifiedSince = null, string with = null) {
			ApiResponse</*ObjectFullDetails*/dynamic> localVarResponse = await GetObjectDetailsAsyncWithHttpInfo (bucketKey, objectName, ifModifiedSince, with);
			return localVarResponse.Data;

		}

		/// <summary>
		///  Returns object details in JSON format.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="with">Extra information in details; multiple uses are supported Acceptable values: &#x60;createdDate&#x60;, &#x60;lastAccessedDate&#x60;, &#x60;lastModifiedDate&#x60;  (optional)</param>
		/// <returns>Task of ApiResponse (ObjectFullDetails)</returns>
		public async System.Threading.Tasks.Task<ApiResponse</*ObjectFullDetails*/dynamic>> GetObjectDetailsAsyncWithHttpInfo (string bucketKey, string objectName, DateTime? ifModifiedSince = null, string with = null) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->GetObjectDetails");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->GetObjectDetails");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}/details";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( with != null )
				localVarQueryParams.Add ("with", Configuration.ApiClient.ParameterToString (with)); // query parameter
			if ( ifModifiedSince != null )
				localVarHeaderParams.Add ("If-Modified-Since", Configuration.ApiClient.ParameterToString (ifModifiedSince)); // header parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Get, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("GetObjectDetails", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectFullDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectFullDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectFullDetails)));

		}

		/// <summary>
		///  List objects in a bucket. It is only available to the bucket creator.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="limit">Limit to the response size, Acceptable values: 1-100 Default &#x3D; 10  (optional, default to 10)</param>
		/// <param name="beginsWith">Provides a way to filter the based on object key name (optional)</param>
		/// <param name="startAt">Key to use as an offset to continue pagination This is typically the last bucket key found in a preceding GET buckets response  (optional)</param>
		/// <returns>BucketObjects</returns>
		public /*BucketObjects*/dynamic GetObjects (string bucketKey, int? limit = null, string beginsWith = null, string startAt = null) {
			ApiResponse</*BucketObjects*/dynamic> localVarResponse = GetObjectsWithHttpInfo (bucketKey, limit, beginsWith, startAt);
			return localVarResponse.Data;
		}

		/// <summary>
		///  List objects in a bucket. It is only available to the bucket creator.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="limit">Limit to the response size, Acceptable values: 1-100 Default &#x3D; 10  (optional, default to 10)</param>
		/// <param name="beginsWith">Provides a way to filter the based on object key name (optional)</param>
		/// <param name="startAt">Key to use as an offset to continue pagination This is typically the last bucket key found in a preceding GET buckets response  (optional)</param>
		/// <returns>ApiResponse of BucketObjects</returns>
		public ApiResponse< /*BucketObjects*/dynamic> GetObjectsWithHttpInfo (string bucketKey, int? limit = null, string beginsWith = null, string startAt = null) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->GetObjects");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( limit != null )
				localVarQueryParams.Add ("limit", Configuration.ApiClient.ParameterToString (limit)); // query parameter
			if ( beginsWith != null )
				localVarQueryParams.Add ("beginsWith", Configuration.ApiClient.ParameterToString (beginsWith)); // query parameter
			if ( startAt != null )
				localVarQueryParams.Add ("startAt", Configuration.ApiClient.ParameterToString (startAt)); // query parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Get, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("GetObjects", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*BucketObjects*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(BucketObjects)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (BucketObjects)));

		}

		/// <summary>
		///  List objects in a bucket. It is only available to the bucket creator.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="limit">Limit to the response size, Acceptable values: 1-100 Default &#x3D; 10  (optional, default to 10)</param>
		/// <param name="beginsWith">Provides a way to filter the based on object key name (optional)</param>
		/// <param name="startAt">Key to use as an offset to continue pagination This is typically the last bucket key found in a preceding GET buckets response  (optional)</param>
		/// <returns>Task of BucketObjects</returns>
		public async System.Threading.Tasks.Task</*BucketObjects*/dynamic> GetObjectsAsync (string bucketKey, int? limit = null, string beginsWith = null, string startAt = null) {
			ApiResponse</*BucketObjects*/dynamic> localVarResponse = await GetObjectsAsyncWithHttpInfo (bucketKey, limit, beginsWith, startAt);
			return localVarResponse.Data;

		}

		/// <summary>
		///  List objects in a bucket. It is only available to the bucket creator.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="limit">Limit to the response size, Acceptable values: 1-100 Default &#x3D; 10  (optional, default to 10)</param>
		/// <param name="beginsWith">Provides a way to filter the based on object key name (optional)</param>
		/// <param name="startAt">Key to use as an offset to continue pagination This is typically the last bucket key found in a preceding GET buckets response  (optional)</param>
		/// <returns>Task of ApiResponse (BucketObjects)</returns>
		public async System.Threading.Tasks.Task<ApiResponse</*BucketObjects*/dynamic>> GetObjectsAsyncWithHttpInfo (string bucketKey, int? limit = null, string beginsWith = null, string startAt = null) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->GetObjects");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( limit != null )
				localVarQueryParams.Add ("limit", Configuration.ApiClient.ParameterToString (limit)); // query parameter
			if ( beginsWith != null )
				localVarQueryParams.Add ("beginsWith", Configuration.ApiClient.ParameterToString (beginsWith)); // query parameter
			if ( startAt != null )
				localVarQueryParams.Add ("startAt", Configuration.ApiClient.ParameterToString (startAt)); // query parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Get, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("GetObjects", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*BucketObjects*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(BucketObjects)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (BucketObjects)));

		}

		/// <summary>
		///  Download an object using a signed URL.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>System.IO.Stream</returns>
		public /*System.IO.Stream*/dynamic GetSignedResource (string id, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null, string region = null) {
			ApiResponse</*System.IO.Stream*/dynamic> localVarResponse = GetSignedResourceWithHttpInfo (id, range, ifNoneMatch, ifModifiedSince, acceptEncoding, region);
			return localVarResponse.Data;
		}

		/// <summary>
		///  Download an object using a signed URL.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>ApiResponse of System.IO.Stream</returns>
		public ApiResponse< /*System.IO.Stream*/dynamic> GetSignedResourceWithHttpInfo (string id, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null, string region = null) {
			// verify the required parameter 'id' is set
			if ( id == null )
				throw new ApiException (400, "Missing required parameter 'id' when calling ObjectsApi->GetSignedResource");

			var localVarPath = "/oss/v2/signedresources/{id}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/octet-stream"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( id != null )
				localVarPathParams.Add ("id", Configuration.ApiClient.ParameterToString (id)); // path parameter
			if ( region != null )
				localVarQueryParams.Add ("region", Configuration.ApiClient.ParameterToString (region)); // query parameter
			if ( range != null )
				localVarHeaderParams.Add ("Range", Configuration.ApiClient.ParameterToString (range)); // header parameter
			if ( ifNoneMatch != null )
				localVarHeaderParams.Add ("If-None-Match", Configuration.ApiClient.ParameterToString (ifNoneMatch)); // header parameter
			if ( ifModifiedSince != null )
				localVarHeaderParams.Add ("If-Modified-Since", Configuration.ApiClient.ParameterToString (ifModifiedSince)); // header parameter
			if ( acceptEncoding != null )
				localVarHeaderParams.Add ("Accept-Encoding", Configuration.ApiClient.ParameterToString (acceptEncoding)); // header parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Get, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("GetSignedResource", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*System.IO.Stream*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(System.IO.Stream)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (System.IO.Stream)));

		}

		/// <summary>
		///  Download an object using a signed URL.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of System.IO.Stream</returns>
		public async System.Threading.Tasks.Task</*System.IO.Stream*/dynamic> GetSignedResourceAsync (string id, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null, string region = null) {
			ApiResponse</*System.IO.Stream*/dynamic> localVarResponse = await GetSignedResourceAsyncWithHttpInfo (id, range, ifNoneMatch, ifModifiedSince, acceptEncoding, region);
			return localVarResponse.Data;

		}

		/// <summary>
		///  Download an object using a signed URL.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="range">A range of bytes to download from the specified object. (optional)</param>
		/// <param name="ifNoneMatch">The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included. (optional)</param>
		/// <param name="ifModifiedSince">If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.  (optional)</param>
		/// <param name="acceptEncoding">When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.  (optional)</param>
		/// <param name="region">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of ApiResponse (System.IO.Stream)</returns>
		public async System.Threading.Tasks.Task<ApiResponse</*System.IO.Stream*/dynamic>> GetSignedResourceAsyncWithHttpInfo (string id, string range = null, string ifNoneMatch = null, DateTime? ifModifiedSince = null, string acceptEncoding = null, string region = null) {
			// verify the required parameter 'id' is set
			if ( id == null )
				throw new ApiException (400, "Missing required parameter 'id' when calling ObjectsApi->GetSignedResource");

			var localVarPath = "/oss/v2/signedresources/{id}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/octet-stream"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( id != null )
				localVarPathParams.Add ("id", Configuration.ApiClient.ParameterToString (id)); // path parameter
			if ( region != null )
				localVarQueryParams.Add ("region", Configuration.ApiClient.ParameterToString (region)); // query parameter
			if ( range != null )
				localVarHeaderParams.Add ("Range", Configuration.ApiClient.ParameterToString (range)); // header parameter
			if ( ifNoneMatch != null )
				localVarHeaderParams.Add ("If-None-Match", Configuration.ApiClient.ParameterToString (ifNoneMatch)); // header parameter
			if ( ifModifiedSince != null )
				localVarHeaderParams.Add ("If-Modified-Since", Configuration.ApiClient.ParameterToString (ifModifiedSince)); // header parameter
			if ( acceptEncoding != null )
				localVarHeaderParams.Add ("Accept-Encoding", Configuration.ApiClient.ParameterToString (acceptEncoding)); // header parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Get, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("GetSignedResource", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*System.IO.Stream*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(System.IO.Stream)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (System.IO.Stream)));

		}

		/// <summary>
		///  This endpoint returns status information about a resumable upload.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <returns></returns>
		public void GetStatusBySessionId (string bucketKey, string objectName, string sessionId) {
			GetStatusBySessionIdWithHttpInfo (bucketKey, objectName, sessionId);
		}

		/// <summary>
		///  This endpoint returns status information about a resumable upload.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <returns>ApiResponse of Object(void)</returns>
		public ApiResponse<Object> GetStatusBySessionIdWithHttpInfo (string bucketKey, string objectName, string sessionId) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->GetStatusBySessionId");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->GetStatusBySessionId");
			// verify the required parameter 'sessionId' is set
			if ( sessionId == null )
				throw new ApiException (400, "Missing required parameter 'sessionId' when calling ObjectsApi->GetStatusBySessionId");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}/status/{sessionId}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( sessionId != null )
				localVarPathParams.Add ("sessionId", Configuration.ApiClient.ParameterToString (sessionId)); // path parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Get, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("GetStatusBySessionId", localVarResponse);
				if ( exception != null )
					throw exception;
			}


			return new ApiResponse<Object> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				null);
		}

		/// <summary>
		///  This endpoint returns status information about a resumable upload.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <returns>Task of void</returns>
		public async System.Threading.Tasks.Task GetStatusBySessionIdAsync (string bucketKey, string objectName, string sessionId) {
			await GetStatusBySessionIdAsyncWithHttpInfo (bucketKey, objectName, sessionId);

		}

		/// <summary>
		///  This endpoint returns status information about a resumable upload.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <returns>Task of ApiResponse</returns>
		public async System.Threading.Tasks.Task<ApiResponse<Object>> GetStatusBySessionIdAsyncWithHttpInfo (string bucketKey, string objectName, string sessionId) {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->GetStatusBySessionId");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->GetStatusBySessionId");
			// verify the required parameter 'sessionId' is set
			if ( sessionId == null )
				throw new ApiException (400, "Missing required parameter 'sessionId' when calling ObjectsApi->GetStatusBySessionId");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}/status/{sessionId}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( sessionId != null )
				localVarPathParams.Add ("sessionId", Configuration.ApiClient.ParameterToString (sessionId)); // path parameter

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Get, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("GetStatusBySessionId", localVarResponse);
				if ( exception != null )
					throw exception;
			}


			return new ApiResponse<Object> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				null);
		}

		/// <summary>
		///  This endpoint allows resumable uploads for large files in chunks.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ObjectDetails</returns>
		public /*ObjectDetails*/dynamic UploadChunk (string bucketKey, string objectName, int? contentLength, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream") {
			ApiResponse</*ObjectDetails*/dynamic> localVarResponse = UploadChunkWithHttpInfo (bucketKey, objectName, contentLength, contentRange, sessionId, body, contentDisposition, ifMatch, contentType);
			return localVarResponse.Data;
		}

		/// <summary>
		///  This endpoint allows resumable uploads for large files in chunks.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ApiResponse of ObjectDetails</returns>
		public ApiResponse< /*ObjectDetails*/dynamic> UploadChunkWithHttpInfo (string bucketKey, string objectName, int? contentLength, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream") {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->UploadChunk");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->UploadChunk");
			// verify the required parameter 'contentLength' is set
			if ( contentLength == null )
				throw new ApiException (400, "Missing required parameter 'contentLength' when calling ObjectsApi->UploadChunk");
			// verify the required parameter 'contentRange' is set
			if ( contentRange == null )
				throw new ApiException (400, "Missing required parameter 'contentRange' when calling ObjectsApi->UploadChunk");
			// verify the required parameter 'sessionId' is set
			if ( sessionId == null )
				throw new ApiException (400, "Missing required parameter 'sessionId' when calling ObjectsApi->UploadChunk");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing required parameter 'body' when calling ObjectsApi->UploadChunk");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}/resumable";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				contentType
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( contentLength != null )
				localVarHeaderParams.Add ("Content-Length", Configuration.ApiClient.ParameterToString (contentLength)); // header parameter
			if ( contentRange != null )
				localVarHeaderParams.Add ("Content-Range", Configuration.ApiClient.ParameterToString (contentRange)); // header parameter
			if ( contentDisposition != null )
				localVarHeaderParams.Add ("Content-Disposition", Configuration.ApiClient.ParameterToString (contentDisposition)); // header parameter
			if ( ifMatch != null )
				localVarHeaderParams.Add ("If-Match", Configuration.ApiClient.ParameterToString (ifMatch)); // header parameter
			if ( sessionId != null )
				localVarHeaderParams.Add ("Session-Id", Configuration.ApiClient.ParameterToString (sessionId)); // header parameter
			if ( body != null && body.GetType () == typeof (byte []) ) // http body (model) parameter
			{
				localVarPostBody = body; // byte array
			} else if ( body != null
					   && (body.GetType () == typeof (System.IO.FileStream)
						   || body.GetType () == typeof (System.IO.BinaryReader)
						   || body.GetType () == typeof (System.IO.BufferedStream)
						   || body.GetType () == typeof (System.IO.MemoryStream)
						   || body.GetType () == typeof (System.IO.StreamReader)
						  )
					  ) {
				localVarPostBody = Configuration.ApiClient.toByteArray (body); // byte array
			} else if ( body != null ) {
				localVarPostBody = Configuration.ApiClient.Serialize (body);
			}

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Put, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("UploadChunk", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectDetails)));

		}

		/// <summary>
		///  This endpoint allows resumable uploads for large files in chunks.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>Task of ObjectDetails</returns>
		public async System.Threading.Tasks.Task</*ObjectDetails*/dynamic> UploadChunkAsync (string bucketKey, string objectName, int? contentLength, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream") {
			ApiResponse</*ObjectDetails*/dynamic> localVarResponse = await UploadChunkAsyncWithHttpInfo (bucketKey, objectName, contentLength, contentRange, sessionId, body, contentDisposition, ifMatch, contentType);
			return localVarResponse.Data;

		}

		/// <summary>
		///  This endpoint allows resumable uploads for large files in chunks.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>Task of ApiResponse (ObjectDetails)</returns>
		public async System.Threading.Tasks.Task<ApiResponse</*ObjectDetails*/dynamic>> UploadChunkAsyncWithHttpInfo (string bucketKey, string objectName, int? contentLength, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream") {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->UploadChunk");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->UploadChunk");
			// verify the required parameter 'contentLength' is set
			if ( contentLength == null )
				throw new ApiException (400, "Missing required parameter 'contentLength' when calling ObjectsApi->UploadChunk");
			// verify the required parameter 'contentRange' is set
			if ( contentRange == null )
				throw new ApiException (400, "Missing required parameter 'contentRange' when calling ObjectsApi->UploadChunk");
			// verify the required parameter 'sessionId' is set
			if ( sessionId == null )
				throw new ApiException (400, "Missing required parameter 'sessionId' when calling ObjectsApi->UploadChunk");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing required parameter 'body' when calling ObjectsApi->UploadChunk");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}/resumable";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				contentType
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( contentLength != null )
				localVarHeaderParams.Add ("Content-Length", Configuration.ApiClient.ParameterToString (contentLength)); // header parameter
			if ( contentRange != null )
				localVarHeaderParams.Add ("Content-Range", Configuration.ApiClient.ParameterToString (contentRange)); // header parameter
			if ( contentDisposition != null )
				localVarHeaderParams.Add ("Content-Disposition", Configuration.ApiClient.ParameterToString (contentDisposition)); // header parameter
			if ( ifMatch != null )
				localVarHeaderParams.Add ("If-Match", Configuration.ApiClient.ParameterToString (ifMatch)); // header parameter
			if ( sessionId != null )
				localVarHeaderParams.Add ("Session-Id", Configuration.ApiClient.ParameterToString (sessionId)); // header parameter
			if ( body != null && body.GetType () == typeof (byte []) ) // http body (model) parameter
			{
				localVarPostBody = body; // byte array
			} else if ( body != null
					   && (body.GetType () == typeof (System.IO.FileStream)
						   || body.GetType () == typeof (System.IO.BinaryReader)
						   || body.GetType () == typeof (System.IO.BufferedStream)
						   || body.GetType () == typeof (System.IO.MemoryStream)
						   || body.GetType () == typeof (System.IO.StreamReader)
						  )
					  ) {
				localVarPostBody = Configuration.ApiClient.toByteArray (body); // byte array
			} else if ( body != null ) {
				localVarPostBody = Configuration.ApiClient.Serialize (body);
			}

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Put, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("UploadChunk", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectDetails)));

		}

		/// <summary>
		///  Upload an object. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination. 
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ObjectDetails</returns>
		public /*ObjectDetails*/dynamic UploadObject (string bucketKey, string objectName, int? contentLength, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream") {
			ApiResponse</*ObjectDetails*/dynamic> localVarResponse = UploadObjectWithHttpInfo (bucketKey, objectName, contentLength, body, contentDisposition, ifMatch, contentType);
			return localVarResponse.Data;
		}

		/// <summary>
		///  Upload an object. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination. 
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ApiResponse of ObjectDetails</returns>
		public ApiResponse< /*ObjectDetails*/dynamic> UploadObjectWithHttpInfo (string bucketKey, string objectName, int? contentLength, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream") {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->UploadObject");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->UploadObject");
			// verify the required parameter 'contentLength' is set
			if ( contentLength == null )
				throw new ApiException (400, "Missing required parameter 'contentLength' when calling ObjectsApi->UploadObject");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing required parameter 'body' when calling ObjectsApi->UploadObject");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				contentType
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( contentLength != null )
				localVarHeaderParams.Add ("Content-Length", Configuration.ApiClient.ParameterToString (contentLength)); // header parameter
			if ( contentDisposition != null )
				localVarHeaderParams.Add ("Content-Disposition", Configuration.ApiClient.ParameterToString (contentDisposition)); // header parameter
			if ( ifMatch != null )
				localVarHeaderParams.Add ("If-Match", Configuration.ApiClient.ParameterToString (ifMatch)); // header parameter
			if ( body != null && body.GetType () == typeof (byte []) ) // http body (model) parameter
			{
				localVarPostBody = body; // byte array
			} else if ( body != null
					   && (body.GetType () == typeof (System.IO.FileStream)
						   || body.GetType () == typeof (System.IO.BinaryReader)
						   || body.GetType () == typeof (System.IO.BufferedStream)
						   || body.GetType () == typeof (System.IO.MemoryStream)
						   || body.GetType () == typeof (System.IO.StreamReader)
						  )
					  ) {
				localVarPostBody = Configuration.ApiClient.toByteArray (body); // byte array
			} else if ( body != null ) {
				localVarPostBody = Configuration.ApiClient.Serialize (body);
			}

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Put, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("UploadObject", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectDetails)));

		}

		/// <summary>
		///  Upload an object. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination. 
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>Task of ObjectDetails</returns>
		public async System.Threading.Tasks.Task</*ObjectDetails*/dynamic> UploadObjectAsync (string bucketKey, string objectName, int? contentLength, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream") {
			ApiResponse</*ObjectDetails*/dynamic> localVarResponse = await UploadObjectAsyncWithHttpInfo (bucketKey, objectName, contentLength, body, contentDisposition, ifMatch, contentType);
			return localVarResponse.Data;

		}

		/// <summary>
		///  Upload an object. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination. 
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">URL-encoded bucket key</param>
		/// <param name="objectName">URL-encoded object name</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>Task of ApiResponse (ObjectDetails)</returns>
		public async System.Threading.Tasks.Task<ApiResponse</*ObjectDetails*/dynamic>> UploadObjectAsyncWithHttpInfo (string bucketKey, string objectName, int? contentLength, System.IO.Stream body, string contentDisposition = null, string ifMatch = null, string contentType = "application/octet-stream") {
			// verify the required parameter 'bucketKey' is set
			if ( bucketKey == null )
				throw new ApiException (400, "Missing required parameter 'bucketKey' when calling ObjectsApi->UploadObject");
			// verify the required parameter 'objectName' is set
			if ( objectName == null )
				throw new ApiException (400, "Missing required parameter 'objectName' when calling ObjectsApi->UploadObject");
			// verify the required parameter 'contentLength' is set
			if ( contentLength == null )
				throw new ApiException (400, "Missing required parameter 'contentLength' when calling ObjectsApi->UploadObject");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing required parameter 'body' when calling ObjectsApi->UploadObject");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectName}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				contentType
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( bucketKey != null )
				localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			if ( objectName != null )
				localVarPathParams.Add ("objectName", Configuration.ApiClient.ParameterToString (objectName)); // path parameter
			if ( contentLength != null )
				localVarHeaderParams.Add ("Content-Length", Configuration.ApiClient.ParameterToString (contentLength)); // header parameter
			if ( contentDisposition != null )
				localVarHeaderParams.Add ("Content-Disposition", Configuration.ApiClient.ParameterToString (contentDisposition)); // header parameter
			if ( ifMatch != null )
				localVarHeaderParams.Add ("If-Match", Configuration.ApiClient.ParameterToString (ifMatch)); // header parameter
			if ( body != null && body.GetType () == typeof (byte []) ) // http body (model) parameter
			{
				localVarPostBody = body; // byte array
			} else if ( body != null
					   && (body.GetType () == typeof (System.IO.FileStream)
						   || body.GetType () == typeof (System.IO.BinaryReader)
						   || body.GetType () == typeof (System.IO.BufferedStream)
						   || body.GetType () == typeof (System.IO.MemoryStream)
						   || body.GetType () == typeof (System.IO.StreamReader)
						  )
					  ) {
				localVarPostBody = Configuration.ApiClient.toByteArray (body); // byte array
			} else if ( body != null ) {
				localVarPostBody = Configuration.ApiClient.Serialize (body);
			}

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Put, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("UploadObject", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectDetails)));

		}

		/// <summary>
		///  Overwrite a existing object using a signed URL.  Conditions to call this operation:  Object is available Expiration period is valid Signed URL should be created with &#x60;write&#x60; or &#x60;readwrite&#x60; 
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ObjectDetails</returns>
		public /*ObjectDetails*/dynamic UploadSignedResource (string id, int? contentLength, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string ifMatch = null, string contentType = "application/octet-stream") {
			ApiResponse</*ObjectDetails*/dynamic> localVarResponse = UploadSignedResourceWithHttpInfo (id, contentLength, body, contentDisposition, xAdsRegion, ifMatch, contentType);
			return localVarResponse.Data;
		}

		/// <summary>
		///  Overwrite a existing object using a signed URL.  Conditions to call this operation:  Object is available Expiration period is valid Signed URL should be created with &#x60;write&#x60; or &#x60;readwrite&#x60; 
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>ApiResponse of ObjectDetails</returns>
		public ApiResponse< /*ObjectDetails*/dynamic> UploadSignedResourceWithHttpInfo (string id, int? contentLength, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string ifMatch = null, string contentType = "application/octet-stream") {
			// verify the required parameter 'id' is set
			if ( id == null )
				throw new ApiException (400, "Missing required parameter 'id' when calling ObjectsApi->UploadSignedResource");
			// verify the required parameter 'contentLength' is set
			if ( contentLength == null )
				throw new ApiException (400, "Missing required parameter 'contentLength' when calling ObjectsApi->UploadSignedResource");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing required parameter 'body' when calling ObjectsApi->UploadSignedResource");

			var localVarPath = "/oss/v2/signedresources/{id}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				contentType
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( id != null )
				localVarPathParams.Add ("id", Configuration.ApiClient.ParameterToString (id)); // path parameter
			if ( contentLength != null )
				localVarHeaderParams.Add ("Content-Length", Configuration.ApiClient.ParameterToString (contentLength)); // header parameter
			if ( contentDisposition != null )
				localVarHeaderParams.Add ("Content-Disposition", Configuration.ApiClient.ParameterToString (contentDisposition)); // header parameter
			if ( xAdsRegion != null )
				localVarHeaderParams.Add ("x-ads-region", Configuration.ApiClient.ParameterToString (xAdsRegion)); // header parameter
			if ( ifMatch != null )
				localVarHeaderParams.Add ("If-Match", Configuration.ApiClient.ParameterToString (ifMatch)); // header parameter
			if ( body != null && body.GetType () == typeof (byte []) ) // http body (model) parameter
			{
				localVarPostBody = body; // byte array
			} else if ( body != null
					   && (body.GetType () == typeof (System.IO.FileStream)
						   || body.GetType () == typeof (System.IO.BinaryReader)
						   || body.GetType () == typeof (System.IO.BufferedStream)
						   || body.GetType () == typeof (System.IO.MemoryStream)
						   || body.GetType () == typeof (System.IO.StreamReader)
						  )
					  ) {
				localVarPostBody = Configuration.ApiClient.toByteArray (body); // byte array
			} else if ( body != null ) {
				localVarPostBody = Configuration.ApiClient.Serialize (body);
			}

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Put, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("UploadSignedResource", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectDetails)));

		}

		/// <summary>
		///  Overwrite a existing object using a signed URL.  Conditions to call this operation:  Object is available Expiration period is valid Signed URL should be created with &#x60;write&#x60; or &#x60;readwrite&#x60; 
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>Task of ObjectDetails</returns>
		public async System.Threading.Tasks.Task</*ObjectDetails*/dynamic> UploadSignedResourceAsync (string id, int? contentLength, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string ifMatch = null, string contentType = "application/octet-stream") {
			ApiResponse</*ObjectDetails*/dynamic> localVarResponse = await UploadSignedResourceAsyncWithHttpInfo (id, contentLength, body, contentDisposition, xAdsRegion, ifMatch, contentType);
			return localVarResponse.Data;

		}

		/// <summary>
		///  Overwrite a existing object using a signed URL.  Conditions to call this operation:  Object is available Expiration period is valid Signed URL should be created with &#x60;write&#x60; or &#x60;readwrite&#x60; 
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentLength">Indicates the size of the request body.</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <param name="ifMatch">If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.  (optional)</param>
		/// <returns>Task of ApiResponse (ObjectDetails)</returns>
		public async System.Threading.Tasks.Task<ApiResponse</*ObjectDetails*/dynamic>> UploadSignedResourceAsyncWithHttpInfo (string id, int? contentLength, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string ifMatch = null, string contentType = "application/octet-stream") {
			// verify the required parameter 'id' is set
			if ( id == null )
				throw new ApiException (400, "Missing required parameter 'id' when calling ObjectsApi->UploadSignedResource");
			// verify the required parameter 'contentLength' is set
			if ( contentLength == null )
				throw new ApiException (400, "Missing required parameter 'contentLength' when calling ObjectsApi->UploadSignedResource");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing required parameter 'body' when calling ObjectsApi->UploadSignedResource");

			var localVarPath = "/oss/v2/signedresources/{id}";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				contentType
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( id != null )
				localVarPathParams.Add ("id", Configuration.ApiClient.ParameterToString (id)); // path parameter
			if ( contentLength != null )
				localVarHeaderParams.Add ("Content-Length", Configuration.ApiClient.ParameterToString (contentLength)); // header parameter
			if ( contentDisposition != null )
				localVarHeaderParams.Add ("Content-Disposition", Configuration.ApiClient.ParameterToString (contentDisposition)); // header parameter
			if ( xAdsRegion != null )
				localVarHeaderParams.Add ("x-ads-region", Configuration.ApiClient.ParameterToString (xAdsRegion)); // header parameter
			if ( ifMatch != null )
				localVarHeaderParams.Add ("If-Match", Configuration.ApiClient.ParameterToString (ifMatch)); // header parameter
			if ( body != null && body.GetType () == typeof (byte []) ) // http body (model) parameter
			{
				localVarPostBody = body; // byte array
			} else if ( body != null
					   && (body.GetType () == typeof (System.IO.FileStream)
						   || body.GetType () == typeof (System.IO.BinaryReader)
						   || body.GetType () == typeof (System.IO.BufferedStream)
						   || body.GetType () == typeof (System.IO.MemoryStream)
						   || body.GetType () == typeof (System.IO.StreamReader)
						  )
					  ) {
				localVarPostBody = Configuration.ApiClient.toByteArray (body); // byte array
			} else if ( body != null ) {
				localVarPostBody = Configuration.ApiClient.Serialize (body);
			}

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Put, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("UploadSignedResource", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectDetails)));

		}

		/// <summary>
		///  Resumable upload for signed URLs.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>ObjectDetails</returns>
		public /*ObjectDetails*/dynamic UploadSignedResourcesChunk (string id, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string contentType = "application/octet-stream") {
			ApiResponse</*ObjectDetails*/dynamic> localVarResponse = UploadSignedResourcesChunkWithHttpInfo (id, contentRange, sessionId, body, contentDisposition, xAdsRegion, contentType);
			return localVarResponse.Data;
		}

		/// <summary>
		///  Resumable upload for signed URLs.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>ApiResponse of ObjectDetails</returns>
		public ApiResponse< /*ObjectDetails*/dynamic> UploadSignedResourcesChunkWithHttpInfo (string id, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string contentType = "application/octet-stream") {
			// verify the required parameter 'id' is set
			if ( id == null )
				throw new ApiException (400, "Missing required parameter 'id' when calling ObjectsApi->UploadSignedResourcesChunk");
			// verify the required parameter 'contentRange' is set
			if ( contentRange == null )
				throw new ApiException (400, "Missing required parameter 'contentRange' when calling ObjectsApi->UploadSignedResourcesChunk");
			// verify the required parameter 'sessionId' is set
			if ( sessionId == null )
				throw new ApiException (400, "Missing required parameter 'sessionId' when calling ObjectsApi->UploadSignedResourcesChunk");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing required parameter 'body' when calling ObjectsApi->UploadSignedResourcesChunk");

			var localVarPath = "/oss/v2/signedresources/{id}/resumable";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				contentType
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( id != null )
				localVarPathParams.Add ("id", Configuration.ApiClient.ParameterToString (id)); // path parameter
			if ( contentRange != null )
				localVarHeaderParams.Add ("Content-Range", Configuration.ApiClient.ParameterToString (contentRange)); // header parameter
			if ( contentDisposition != null )
				localVarHeaderParams.Add ("Content-Disposition", Configuration.ApiClient.ParameterToString (contentDisposition)); // header parameter
			if ( xAdsRegion != null )
				localVarHeaderParams.Add ("x-ads-region", Configuration.ApiClient.ParameterToString (xAdsRegion)); // header parameter
			if ( sessionId != null )
				localVarHeaderParams.Add ("Session-Id", Configuration.ApiClient.ParameterToString (sessionId)); // header parameter
			if ( body != null && body.GetType () == typeof (byte []) ) // http body (model) parameter
			{
				localVarPostBody = body; // byte array
			} else if ( body != null
					   && (body.GetType () == typeof (System.IO.FileStream)
						   || body.GetType () == typeof (System.IO.BinaryReader)
						   || body.GetType () == typeof (System.IO.BufferedStream)
						   || body.GetType () == typeof (System.IO.MemoryStream)
						   || body.GetType () == typeof (System.IO.StreamReader)
						  )
					  ) {
				localVarPostBody = Configuration.ApiClient.toByteArray (body); // byte array
			} else if ( body != null ) {
				localVarPostBody = Configuration.ApiClient.Serialize (body);
			}

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)Configuration.ApiClient.CallApi (localVarPath,
				Method.Put, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("UploadSignedResourcesChunk", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectDetails)));

		}

		/// <summary>
		///  Resumable upload for signed URLs.
		/// </summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of ObjectDetails</returns>
		public async System.Threading.Tasks.Task</*ObjectDetails*/dynamic> UploadSignedResourcesChunkAsync (string id, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string contentType = "application/octet-stream") {
			ApiResponse</*ObjectDetails*/dynamic> localVarResponse = await UploadSignedResourcesChunkAsyncWithHttpInfo (id, contentRange, sessionId, body, contentDisposition, xAdsRegion, contentType);
			return localVarResponse.Data;
		}

		/// <summary>Resumable upload for signed URLs.</summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="id">Id of signed resource</param>
		/// <param name="contentRange">Byte range of a segment being uploaded</param>
		/// <param name="sessionId">Unique identifier of a session of a file being uploaded</param>
		/// <param name="body"></param>
		/// <param name="contentDisposition">The suggested default filename when downloading this object to a file after it has been uploaded. (optional)</param>
		/// <param name="xAdsRegion">The region where the bucket resides Acceptable values: &#x60;US&#x60;, &#x60;EMEA&#x60; Default is &#x60;US&#x60;  (optional, default to US)</param>
		/// <returns>Task of ApiResponse (ObjectDetails)</returns>
		public async System.Threading.Tasks.Task<ApiResponse</*ObjectDetails*/dynamic>> UploadSignedResourcesChunkAsyncWithHttpInfo (string id, string contentRange, string sessionId, System.IO.Stream body, string contentDisposition = null, string xAdsRegion = null, string contentType = "application/octet-stream") {
			// verify the required parameter 'id' is set
			if ( id == null )
				throw new ApiException (400, "Missing required parameter 'id' when calling ObjectsApi->UploadSignedResourcesChunk");
			// verify the required parameter 'contentRange' is set
			if ( contentRange == null )
				throw new ApiException (400, "Missing required parameter 'contentRange' when calling ObjectsApi->UploadSignedResourcesChunk");
			// verify the required parameter 'sessionId' is set
			if ( sessionId == null )
				throw new ApiException (400, "Missing required parameter 'sessionId' when calling ObjectsApi->UploadSignedResourcesChunk");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing required parameter 'body' when calling ObjectsApi->UploadSignedResourcesChunk");

			var localVarPath = "/oss/v2/signedresources/{id}/resumable";
			var localVarPathParams = new Dictionary<string, string> ();
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				contentType
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( localVarHttpHeaderAccept != null )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// set "format" to json by default
			// e.g. /pet/{petId}.{format} becomes /pet/{petId}.json
			localVarPathParams.Add ("format", "json");
			if ( id != null )
				localVarPathParams.Add ("id", Configuration.ApiClient.ParameterToString (id)); // path parameter
			if ( contentRange != null )
				localVarHeaderParams.Add ("Content-Range", Configuration.ApiClient.ParameterToString (contentRange)); // header parameter
			if ( contentDisposition != null )
				localVarHeaderParams.Add ("Content-Disposition", Configuration.ApiClient.ParameterToString (contentDisposition)); // header parameter
			if ( xAdsRegion != null )
				localVarHeaderParams.Add ("x-ads-region", Configuration.ApiClient.ParameterToString (xAdsRegion)); // header parameter
			if ( sessionId != null )
				localVarHeaderParams.Add ("Session-Id", Configuration.ApiClient.ParameterToString (sessionId)); // header parameter
			if ( body != null && body.GetType () == typeof (byte []) ) // http body (model) parameter
			{
				localVarPostBody = body; // byte array
			} else if ( body != null
					   && (body.GetType () == typeof (System.IO.FileStream)
						   || body.GetType () == typeof (System.IO.BinaryReader)
						   || body.GetType () == typeof (System.IO.BufferedStream)
						   || body.GetType () == typeof (System.IO.MemoryStream)
						   || body.GetType () == typeof (System.IO.StreamReader)
						  )
					  ) {
				localVarPostBody = Configuration.ApiClient.toByteArray (body); // byte array
			} else if ( body != null ) {
				localVarPostBody = Configuration.ApiClient.Serialize (body);
			}

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) ) {
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;
			}

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (localVarPath,
				Method.Put, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("UploadSignedResourcesChunk", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return new ApiResponse</*ObjectDetails*/dynamic> (localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				/*(ObjectDetails)*/ Configuration.ApiClient.Deserialize (localVarResponse, typeof (ObjectDetails)));

		}

		#region Direct S3

		protected Dictionary<string, string> Opts2Dictionary (Dictionary<string, object> opts, Dictionary<string, string> keys, Dictionary<string, string> input = null) {
			if ( input == null )
				input = new Dictionary<string, string> ();
			if ( opts == null )
				return (input);

			foreach ( var param in opts ) {
				if ( keys.ContainsKey (param.Key) )
					input.Add (keys [param.Key], Configuration.ApiClient.ParameterToString (param.Value));
			}

			return (input);
		}

		/// summary>Returns a signed S3 URL.</summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.ifNoneMatch">{String=} If the value of this header matches the ETag of the object, an entity will not be returned from the server; 
		/// instead a 304 (not modified) response will be returned without any message-body.</param>
		/// <param name="opts.ifModifiedSince">{Date=} If the requested object has not been modified since the time specified in this field,
		/// an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message-body.</param>
		/// <param name="opts.responseContentType">{String=} Value of the Content-Type header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.responseContentDisposition">{String=} Value of the Content Disposition header the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.responseCacheControl">{String=} Value of the Cache-Control header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.publicResourceFallback">{Boolean=false} Allows fallback to OSS signed URLs in case of unmerged resumable uploads.</param>
		/// <param name="opts.useCdn">{Boolean=true} Will generate a CloudFront URL for the S3 object.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3download-GET/</href>
		/// <returns>Task of ApiResponse (ObjectS3Download)</returns>
		public async System.Threading.Tasks.Task<dynamic> getS3DownloadURLAsync (string bucketKey, string objectKey, Dictionary<string, object> opts = null) {
			ApiResponse<dynamic> localVarResponse = await getS3DownloadURLAsyncWithHttpInfo (bucketKey, objectKey, opts);
			return (localVarResponse.Data);
		}

		/// summary>Returns a signed S3 URL.</summary>
		/// <exception cref="Autodesk.Forge.Client.ApiException">Thrown when fails to make API call</exception>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.ifNoneMatch">{String=} If the value of this header matches the ETag of the object, an entity will not be returned from the server; 
		/// instead a 304 (not modified) response will be returned without any message-body.</param>
		/// <param name="opts.ifModifiedSince">{Date=} If the requested object has not been modified since the time specified in this field,
		/// an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message-body.</param>
		/// <param name="opts.responseContentType">{String=} Value of the Content-Type header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.responseContentDisposition">{String=} Value of the Content Disposition header the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.responseCacheControl">{String=} Value of the Cache-Control header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="opts.publicResourceFallback">{Boolean=false} Allows fallback to OSS signed URLs in case of unmerged resumable uploads.</param>
		/// <param name="opts.useCdn">{Boolean=true} Will generate a CloudFront URL for the S3 object.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3download-GET/</href>
		/// <returns>Task of ApiResponse (ObjectS3Download)</returns>
		public async System.Threading.Tasks.Task<ApiResponse<dynamic>> getS3DownloadURLAsyncWithHttpInfo (string bucketKey, string objectKey, Dictionary<string, object> opts = null) {
			// verify the required parameter 'bucketKey' is set
			if ( String.IsNullOrEmpty (bucketKey) )
				throw new ApiException (400, "Missing the required parameter 'bucketKey' when calling getS3DownloadURLAsyncWithHttpInfo");
			// verify the required parameter 'objectKey' is set
			if ( String.IsNullOrEmpty (objectKey) )
				throw new ApiException (400, "Missing the required parameter 'objectKey' when calling getS3DownloadURLAsyncWithHttpInfo");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectKey}/signeds3download";
			var localVarPathParams = new Dictionary<string, string> ();
			localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			localVarPathParams.Add ("objectKey", Configuration.ApiClient.ParameterToString (objectKey)); // path parameter
			var localVarQueryParams = Opts2Dictionary (
				opts,
				new Dictionary<string, string> () {
					{ "response-content-type", "response-content-type" },
					{ "response-content-disposition","response-content-disposition" },
					{ "response-cache-control", "response-cache-control" },
					{ "public-resource-fallback", "public-resource-fallback" },
					{ "responseContentType", "response-content-type" },
					{ "responseContentDisposition","response-content-disposition" },
					{ "responseCacheControl", "response-cache-control" },
					{ "publicResourceFallback", "public-resource-fallback" },
					{ "useCdn", "useCdn" },
					{ "minutesExpiration", "minutesExpiration" }
				}
			);

			var localVarHeaderParams = Opts2Dictionary (
				opts,
				new Dictionary<string, string> () {
					{ "If-None-Match", "If-None-Match" },
					{ "If-Modified-Since", "If-Modified-Since" },
					{ "ifNoneMatch", "If-None-Match" },
					{ "ifModifiedSince", "If-Modified-Since" }
				},
				new Dictionary<string, string> (Configuration.DefaultHeader)
			);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			//String [] localVarHttpContentTypes = new String [] {
			//	contentType
			//};
			//String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);
			String localVarHttpContentType = null;

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( !String.IsNullOrEmpty (localVarHttpHeaderAccept) )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) )
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (
				localVarPath, Method.Get,
				localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType
			);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("getS3DownloadURLAsyncWithHttpInfo", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return (new ApiResponse<dynamic> (
				localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				Configuration.ApiClient.Deserialize (localVarResponse, null)
			));
		}

		/// <summary>
		/// Gets one or more signed URLs to objects. The signed URLs can be used to download the objects directly from S3, skipping OSS servers.
		/// Be aware that expiration time for the signed URL(s) is just 60 seconds. So, a request to the URL(s) must begin within 60 seconds; the transfer
		/// of the data can exceed 60 seconds.
		/// A successful call to this endpoint requires bucket owner access.
		/// Note that resumable uploads store each chunk individually. After upload completes, an async process merges all the chunks and creates the 
		/// definitive OSS file. This async process can take time. If you request an S3 download URL before the async process completes, the response returns
		/// a map of S3 URLs, one per chunk where the key is the corresponding range bytes. In case you don't want multiple URLs in the response, you can use 
		/// OSS signed URL functionality , with the public-resource-fallback query parameter set to true.
		/// Note: While this endpoint does not support range headers, the returned URL(s) can be used for ranged downloads. This way, downloads can be 
		/// parallelized using multiple ranges for maximum speed.
		/// </summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter</param>
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} Object name to create a download S3 signed URL for</param>
		/// <param name="body.requests[].response-content-type">{String=} Value of the Content-Type header that the client expects to receive. 
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].response-content-disposition">{String=} Value of the Content Disposition header the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].response-cache-control">{String=} Value of the Cache-Control header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].IfcNonecMatch">{String=} The value of this attribute is compared to the ETAG of the object. 
		/// If they match, the response body will show the status of this item as "skipped" with the reason as "Not modified".</param>
		/// <param name="body.requests[].If-Modified-Since">{Date=} If the requested object has not been modified since the time specified in this attribute,
		/// the response body will show the status of this item as "skipped" with the reason as "Not modified".</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.publicResourceFallback">{Boolean=false} (public-resource-fallback) Allows fallback to OSS signed URLs in case of unmerged resumable uploads.</param>
		/// <param name="opts.useCdn">{Boolean=true} Will generate a CloudFront URL for the S3 object.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-batchsigneds3download-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		public async System.Threading.Tasks.Task<dynamic> getS3DownloadURLsAsync (string bucketKey, PostBatchSignedS3DownloadPayload body, Dictionary<string, object> opts = null) {
			ApiResponse<dynamic> localVarResponse = await getS3DownloadURLsAsyncWithHttpInfo (bucketKey, body, opts);
			return (localVarResponse.Data);
		}

		/// <summary>
		/// Gets one or more signed URLs to objects. The signed URLs can be used to download the objects directly from S3, skipping OSS servers.
		/// Be aware that expiration time for the signed URL(s) is just 60 seconds. So, a request to the URL(s) must begin within 60 seconds; the transfer
		/// of the data can exceed 60 seconds.
		/// A successful call to this endpoint requires bucket owner access.
		/// Note that resumable uploads store each chunk individually. After upload completes, an async process merges all the chunks and creates the 
		/// definitive OSS file. This async process can take time. If you request an S3 download URL before the async process completes, the response returns
		/// a map of S3 URLs, one per chunk where the key is the corresponding range bytes. In case you don't want multiple URLs in the response, you can use 
		/// OSS signed URL functionality , with the public-resource-fallback query parameter set to true.
		/// Note: While this endpoint does not support range headers, the returned URL(s) can be used for ranged downloads. This way, downloads can be 
		/// parallelized using multiple ranges for maximum speed.
		/// </summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter</param>
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} Object name to create a download S3 signed URL for</param>
		/// <param name="body.requests[].response-content-type">{String=} Value of the Content-Type header that the client expects to receive. 
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].response-content-disposition">{String=} Value of the Content Disposition header the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].response-cache-control">{String=} Value of the Cache-Control header that the client expects to receive.
		/// If this attribute is not provided, it defaults to the value corresponding to the object.</param>
		/// <param name="body.requests[].If-None-Match">{String=} The value of this attribute is compared to the ETAG of the object. 
		/// If they match, the response body will show the status of this item as "skipped" with the reason as "Not modified".</param>
		/// <param name="body.requests[].If-Modified-Since">{Date=} If the requested object has not been modified since the time specified in this attribute,
		/// the response body will show the status of this item as "skipped" with the reason as "Not modified".</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.publicResourceFallback">{Boolean=false} (public-resource-fallback) Allows fallback to OSS signed URLs in case of unmerged resumable uploads.</param>
		/// <param name="opts.useCdn">{Boolean=true} Will generate a CloudFront URL for the S3 object.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-batchsigneds3download-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		public async System.Threading.Tasks.Task<ApiResponse<dynamic>> getS3DownloadURLsAsyncWithHttpInfo (string bucketKey, PostBatchSignedS3DownloadPayload body, Dictionary<string, object> opts = null) {
			// verify the required parameter 'bucketKey' is set
			if ( String.IsNullOrEmpty (bucketKey) )
				throw new ApiException (400, "Missing the required parameter 'bucketKey' when calling getS3DownloadURLsAsyncWithHttpInfo");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing the required parameter 'body' when calling getS3DownloadURLsAsyncWithHttpInfo");
			if ( body.requests == null || body.requests.Count == 0 )
				throw new ApiException (400, "Missing the required parameter 'body.requests' when calling getS3DownloadURLsAsyncWithHttpInfo");
			foreach ( var item in body.requests ) {
				if ( String.IsNullOrEmpty (item.objectKey) )
					throw new ApiException (400, "Missing the required parameter 'body.requests[].objectKey' when calling getS3DownloadURLsAsyncWithHttpInfo");
			}

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/batchsigneds3download";
			var localVarPathParams = new Dictionary<string, string> ();
			localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter

			var localVarQueryParams = Opts2Dictionary (
				opts,
				new Dictionary<string, string> () {
					{ "public-resource-fallback", "public-resource-fallback" },
					{ "publicResourceFallback", "public-resource-fallback" },
					{ "useCdn", "useCdn" },
					{ "minutesExpiration", "minutesExpiration" }
				}
			);
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();

			Object localVarPostBody = null;
			if ( body != null && body.GetType () == typeof (byte []) ) { // http body (model) parameter
				localVarPostBody = body; // byte array
			} else if ( body != null
					   && (body.GetType () == typeof (System.IO.FileStream)
							|| body.GetType () == typeof (System.IO.BinaryReader)
							|| body.GetType () == typeof (System.IO.BufferedStream)
							|| body.GetType () == typeof (System.IO.MemoryStream)
							|| body.GetType () == typeof (System.IO.StreamReader)
						)
			) {
				localVarPostBody = Configuration.ApiClient.toByteArray (body); // byte array
			} else if ( body != null ) {
				localVarPostBody = Configuration.ApiClient.Serialize (body);
			}

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( !String.IsNullOrEmpty (localVarHttpHeaderAccept) )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) )
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (
				localVarPath, Method.Post,
				localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType
			);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("getS3DownloadURLsAsyncWithHttpInfo", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return (new ApiResponse<dynamic> (
				localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				Configuration.ApiClient.Deserialize (localVarResponse, null)
			));
		}

		/// <summary>Requests an S3 signed URL with which to upload an object, or an array of signed URLs with which to upload an object in multiple parts.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.uploadKey">{String=} Get a new set of signed urls if the ones that were generated before have already expired and the user 
		/// still needs to upload some of them.</param>
		/// <param name="opts.firstParts" default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.</param>
		/// <param name="opts.parts: default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.
		/// </param>
		/// <param name="opts.useAcceleration">{Boolean=true} Whether or not to generate an accelerated signed URL (ie: URLs of 
		/// the form …s3-accelerate.amazonaws.com… vs …s3.amazonaws.com…).
		/// When not specified, defaults to true. Providing non-boolean values will result in a 400 error.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3upload-GET/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		public async System.Threading.Tasks.Task<dynamic> getS3UploadURLAsync (string bucketKey, string objectKey, Dictionary<string, object> opts = null) {
			ApiResponse<dynamic> localVarResponse = await getS3UploadURLAsyncWithHttpInfo (bucketKey, objectKey, opts);
			return (localVarResponse.Data);
		}

		/// <summary>Requests an S3 signed URL with which to upload an object, or an array of signed URLs with which to upload an object in multiple parts.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.uploadKey">{String=} Get a new set of signed urls if the ones that were generated before have already expired and the user 
		/// still needs to upload some of them.</param>
		/// <param name="opts.firstParts" default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.</param>
		/// <param name="opts.parts: default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.
		/// </param>
		/// <param name="opts.useAcceleration">{Boolean=true} Whether or not to generate an accelerated signed URL (ie: URLs of 
		/// the form …s3-accelerate.amazonaws.com… vs …s3.amazonaws.com…).
		/// When not specified, defaults to true. Providing non-boolean values will result in a 400 error.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3upload-GET/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		public async System.Threading.Tasks.Task<ApiResponse<dynamic>> getS3UploadURLAsyncWithHttpInfo (string bucketKey, string objectKey, Dictionary<string, object> opts = null) {
			// verify the required parameter 'bucketKey' is set
			if ( String.IsNullOrEmpty (bucketKey) )
				throw new ApiException (400, "Missing the required parameter 'bucketKey' when calling getS3UploadURLAsyncWithHttpInfo");
			// verify the required parameter 'objectKey' is set
			if ( String.IsNullOrEmpty (objectKey) )
				throw new ApiException (400, "Missing the required parameter 'objectKey' when calling getS3UploadURLAsyncWithHttpInfo");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectKey}/signeds3upload";
			var localVarPathParams = new Dictionary<string, string> ();
			localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			localVarPathParams.Add ("objectKey", Configuration.ApiClient.ParameterToString (objectKey)); // path parameter
			var localVarQueryParams = Opts2Dictionary (
				opts,
				new Dictionary<string, string> () {
					{ "uploadKey", "uploadKey" },
					{ "firstPart", "firstPart" },
					{ "parts", "parts" },
					{ "useAcceleration", "useAcceleration" },
					{ "minutesExpiration", "minutesExpiration" }
				}
			);
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = null;

			// to determine the Content-Type header
			//String [] localVarHttpContentTypes = new String [] {
			//	contentType
			//};
			//String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);
			String localVarHttpContentType = null;

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( !String.IsNullOrEmpty (localVarHttpHeaderAccept) )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) )
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (
				localVarPath, Method.Get,
				localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType
			);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("getS3UploadURLAsyncWithHttpInfo", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return (new ApiResponse<dynamic> (
				localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				Configuration.ApiClient.Deserialize (localVarResponse, null)
			));
		}

		/// <summary>Instructs OSS to complete the object creation process after the bytes have been uploaded directly to S3.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} </param>
		/// <param name="body.uploadKey">{String} The identifier of the upload session, which was provided by OSS in the response to the Get Upload URL/s request.</param>
		/// <param name="body.size">{Integer=} The expected size of the uploaded object. If provided, OSS will check this against the blob in S3 and return
		/// an error if the size does not match.</param>
		/// <param name="body.eTags">{List<String>=} An array of eTags. S3 returns an eTag to each upload request, be it for a chunk or an entire file.
		/// For a single-part upload, this array contains the expected eTag of the entire object. For a multipart upload, this array contains the expected 
		/// eTag of each part of the upload; the index of an eTag in the array corresponds to its part number in the upload. If provided, OSS will validate 
		/// these eTags against the content in S3, and return an error if the eTags do not match (indicating some form of data corruption).</param>
		/// <param name="opts">{Object=} Optional parameters
		/// <param name="opts.xAdsMetaContentType">{String=} (x-ads-meta-Content-Type) The Content-Type value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts.xAdsMetaContentDisposition">{String=} (x-ads-meta-Content-Disposition) The Content-Disposition value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts.xAdsMetaContentEncoding">{String=} (x-ads-meta-Content-Encoding) The Content-Encoding value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts.xAdsMetaCacheControl">{String=} (x-ads-meta-Cache-Control) The Cache-Control value that OSS will store in the record for the uploaded object.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3upload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		public async System.Threading.Tasks.Task<dynamic> completeS3UploadAsync (string bucketKey, string objectKey, PostCompleteS3UploadPayload body, Dictionary<string, object> opts = null) {
			ApiResponse<dynamic> localVarResponse = await completeS3UploadAsyncWithHttpInfo (bucketKey, objectKey, body, opts);
			return (localVarResponse.Data);
		}

		/// <summary>Instructs OSS to complete the object creation process after the bytes have been uploaded directly to S3.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objectKey">{String} object key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} </param>
		/// <param name="body.uploadKey">{String} The identifier of the upload session, which was provided by OSS in the response to the Get Upload URL/s request.</param>
		/// <param name="body.size">{Integer=} The expected size of the uploaded object. If provided, OSS will check this against the blob in S3 and return
		/// an error if the size does not match.</param>
		/// <param name="body.eTags">{List<String>=} An array of eTags. S3 returns an eTag to each upload request, be it for a chunk or an entire file.
		/// For a single-part upload, this array contains the expected eTag of the entire object. For a multipart upload, this array contains the expected 
		/// eTag of each part of the upload; the index of an eTag in the array corresponds to its part number in the upload. If provided, OSS will validate 
		/// these eTags against the content in S3, and return an error if the eTags do not match (indicating some form of data corruption).</param>
		/// <param name="opts">{Object=} Optional parameters
		/// <param name="opts.xAdsMetaContentType">{String=} (x-ads-meta-Content-Type) The Content-Type value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts.xAdsMetaContentDisposition">{String=} (x-ads-meta-Content-Disposition) The Content-Disposition value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts.xAdsMetaContentEncoding">{String=} (x-ads-meta-Content-Encoding) The Content-Encoding value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts.xAdsMetaCacheControl">{String=} (x-ads-meta-Cache-Control) The Cache-Control value that OSS will store in the record for the uploaded object.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-signeds3upload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		public async System.Threading.Tasks.Task<ApiResponse<dynamic>> completeS3UploadAsyncWithHttpInfo (string bucketKey, string objectKey, PostCompleteS3UploadPayload body, Dictionary<string, object> opts = null) {
			// verify the required parameter 'bucketKey' is set
			if ( String.IsNullOrEmpty (bucketKey) )
				throw new ApiException (400, "Missing the required parameter 'bucketKey' when calling completeS3UploadAsyncWithHttpInfo");
			// verify the required parameter 'objectKey' is set
			if ( String.IsNullOrEmpty (objectKey) )
				throw new ApiException (400, "Missing the required parameter 'objectKey' when calling completeS3UploadAsyncWithHttpInfo");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing the required parameter 'body' when calling completeS3UploadAsyncWithHttpInfo");
			if ( body.eTags != null && body.eTags.Count == 0 )
				throw new ApiException (400, "Invalid 'body.eTags' parameter when calling completeS3UploadAsyncWithHttpInfo");
			if ( String.IsNullOrEmpty (body.uploadKey) )
				throw new ApiException (400, "Missing the required parameter 'body.uploadKey' when calling completeS3UploadAsyncWithHttpInfo");

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/{objectKey}/signeds3upload";
			var localVarPathParams = new Dictionary<string, string> ();
			localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			localVarPathParams.Add ("objectKey", Configuration.ApiClient.ParameterToString (objectKey)); // path parameter
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = Opts2Dictionary (
				opts,
				new Dictionary<string, string> () {
					{ "x-ads-meta-Content-Type", "x-ads-meta-Content-Type" },
					{ "x-ads-meta-Content-Disposition", "x-ads-meta-Content-Disposition" },
					{ "x-ads-meta-Content-Encoding", "x-ads-meta-Content-Encoding" },
					{ "x-ads-meta-Cache-Control", "x-ads-meta-Cache-Control" },
					{ "xAdsMetaContentType", "x-ads-meta-Content-Type" },
					{ "xAdsMetaContentDisposition", "x-ads-meta-Content-Disposition" },
					{ "xAdsMetaContentEncoding", "x-ads-meta-Content-Encoding" },
					{ "xAdsMetaCacheControl", "x-ads-meta-Cache-Control" }
				},
				new Dictionary<string, string> (Configuration.DefaultHeader)
			);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = body;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( !String.IsNullOrEmpty (localVarHttpHeaderAccept) )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) )
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (
				localVarPath, Method.Post,
				localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType
			);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("completeS3UploadAsyncWithHttpInfo", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return (new ApiResponse<dynamic> (
				localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				Configuration.ApiClient.Deserialize (localVarResponse, null)
			));
		}

		/// <summary>Instructs OSS to complete the object creation process for numerous objects after their bytes have been uploaded directly to S3.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} The key/name of the object for which to complete an upload.</param>
		/// <param name="body.requests[].uploadKey">{String} The identifier of the upload session, which was provided by OSS in the response to the Get Upload URL/s request.</param>
		/// <param name="body.requests[].size">{Integer=} The expected size of the uploaded object. If provided, OSS will check this against the blob in S3 and return
		/// an error if the size does not match.</param>
		/// <param name="body.requests[].eTags">{String[]=} An array of eTags. S3 returns an eTag to each upload request, be it for a chunk or an entire file.
		/// For a single-part upload, this array contains the expected eTag of the entire object. For a multipart upload, this array contains the expected 
		/// eTag of each part of the upload; the index of an eTag in the array corresponds to its part number in the upload. If provided, OSS will validate 
		/// these eTags against the content in S3, and return an error if the eTags do not match (indicating some form of data corruption).</param>
		/// <param name="body.requests[].xAdsMetaContentType">{String=} (x-ads-meta-Content-Type) The Content-Type value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaContentDisposition">{String=} (x-ads-meta-Content-Disposition) The Content-Disposition value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaContentEncoding">{String=} (x-ads-meta-Content-Encoding) The Content-Encoding value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaCacheControl">{String=} (x-ads-meta-Cache-Control) The Cache-Control value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-batchcompleteupload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		public async System.Threading.Tasks.Task<dynamic> completeS3UploadsAsync (string bucketKey, PostBatchCompleteS3UploadPayload body, Dictionary<string, object> opts = null) {
			ApiResponse<dynamic> localVarResponse = await completeS3UploadsAsyncWithHttpInfo (bucketKey, body, opts);
			return (localVarResponse.Data);
		}

		/// <summary>Instructs OSS to complete the object creation process for numerous objects after their bytes have been uploaded directly to S3.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} The key/name of the object for which to complete an upload.</param>
		/// <param name="body.requests[].uploadKey">{String} The identifier of the upload session, which was provided by OSS in the response to the Get Upload URL/s request.</param>
		/// <param name="body.requests[].size">{Integer=} The expected size of the uploaded object. If provided, OSS will check this against the blob in S3 and return
		/// an error if the size does not match.</param>
		/// <param name="body.requests[].eTags">{String[]=} An array of eTags. S3 returns an eTag to each upload request, be it for a chunk or an entire file.
		/// For a single-part upload, this array contains the expected eTag of the entire object. For a multipart upload, this array contains the expected 
		/// eTag of each part of the upload; the index of an eTag in the array corresponds to its part number in the upload. If provided, OSS will validate 
		/// these eTags against the content in S3, and return an error if the eTags do not match (indicating some form of data corruption).</param>
		/// <param name="body.requests[].xAdsMetaContentType">{String=} (x-ads-meta-Content-Type) The Content-Type value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaContentDisposition">{String=} (x-ads-meta-Content-Disposition) The Content-Disposition value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaContentEncoding">{String=} (x-ads-meta-Content-Encoding) The Content-Encoding value that OSS will store in the record for the uploaded object.</param>
		/// <param name="body.requests[].xAdsMetaCacheControl">{String=} (x-ads-meta-Cache-Control) The Cache-Control value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-batchcompleteupload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		public async System.Threading.Tasks.Task<ApiResponse<dynamic>> completeS3UploadsAsyncWithHttpInfo (string bucketKey, PostBatchCompleteS3UploadPayload body, Dictionary<string, object> opts = null) {
			// verify the required parameter 'bucketKey' is set
			if ( String.IsNullOrEmpty (bucketKey) )
				throw new ApiException (400, "Missing the required parameter 'bucketKey' when calling completeS3UploadsAsyncWithHttpInfo");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing the required parameter 'body' when calling completeS3UploadsAsyncWithHttpInfo");
			if ( body.requests == null || body.requests.Count == 0 )
				throw new ApiException (400, "Missing the required parameter 'body.requests' when calling completeS3UploadsAsyncWithHttpInfo");
			for ( int i = 0 ; i < body.requests.Count ; i++ ) {
				if ( String.IsNullOrEmpty (body.requests [i].objectKey) )
					throw new ApiException (400, "Missing the required parameter 'body.requests[].objectKey' when calling completeS3UploadsAsyncWithHttpInfo");
				if ( String.IsNullOrEmpty (body.requests [i].uploadKey) )
					throw new ApiException (400, "Missing the required parameter 'body.requests[].uploadKey' when calling completeS3UploadsAsyncWithHttpInfo");
				if ( body.requests [i].eTags != null && body.requests [i].eTags.Count == 0 )
					throw new ApiException (400, "Invalid 'body.requests[i].eTags' parameter when calling completeS3UploadsAsyncWithHttpInfo");
			}

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/batchcompleteupload";
			var localVarPathParams = new Dictionary<string, string> ();
			localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			var localVarQueryParams = new Dictionary<string, string> ();
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = body;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( !String.IsNullOrEmpty (localVarHttpHeaderAccept) )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) )
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (
				localVarPath, Method.Post,
				localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType
			);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("completeS3UploadsAsyncWithHttpInfo", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return (new ApiResponse<dynamic> (
				localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				Configuration.ApiClient.Deserialize (localVarResponse, null)
			));
		}

		/// <summary>Requests a batch of S3 signed URL with which to upload multiple objects or chunks of multiple objects.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter</param>
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} The key/name of the object for which to create an S3 upload URL. If neither the "part" nor "parts"
		/// attribute is provided, OSS will return a single upload URL with which to upload the entire object.</param>
		/// <param name="body.requests[].uploadKey">{String=} Get a new set of signed urls if the ones that were generated before have already expired and the user 
		/// still needs to upload some of them.</param>
		/// <param name="body.requests[].firstParts" default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.
		/// @param {Integer=} [body.requests[].parts=1] For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.useAcceleration">{Boolean=true} Whether or not to generate an accelerated signed URL (ie: URLs of
		/// the form …s3-accelerate.amazonaws.com… vs …s3.amazonaws.com…).
		/// When not specified, defaults to true. Providing non-boolean values will result in a 400 error.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-batchsigneds3upload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		public async System.Threading.Tasks.Task<dynamic> getS3UploadURLsAsync (string bucketKey, PostBatchSignedS3UploadPayload body, Dictionary<string, object> opts = null) {
			ApiResponse<dynamic> localVarResponse = await getS3UploadURLsAsyncWithHttpInfo (bucketKey, body, opts);
			return (localVarResponse.Data);
		}

		/// <summary>Requests a batch of S3 signed URL with which to upload multiple objects or chunks of multiple objects.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="body">{Object} body parameter</param>
		/// <param name="body.requests">{Object[]} An array of objects representing each request to get an S3 URL to download from.</param>
		/// <param name="body.requests[].objectKey">{String} The key/name of the object for which to create an S3 upload URL. If neither the "part" nor "parts"
		/// attribute is provided, OSS will return a single upload URL with which to upload the entire object.</param>
		/// <param name="body.requests[].uploadKey">{String=} Get a new set of signed urls if the ones that were generated before have already expired and the user 
		/// still needs to upload some of them.</param>
		/// <param name="body.requests[].firstParts" default="1">{Integer=} For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.
		/// @param {Integer=} [body.requests[].parts=1] For a multipart upload, is the starting index when getting upload part URL. 
		/// If this parameter is not specified the default value is firstPart = 1. 
		/// Example: To retrieve the parts from 10 to 15 you should pass firstPart = 10 and parts = 6, this will retrieve the parts 10, 11, 12, 13, 14 and 15.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.useAcceleration">{Boolean=true} Whether or not to generate an accelerated signed URL (ie: URLs of
		/// the form …s3-accelerate.amazonaws.com… vs …s3.amazonaws.com…).
		/// When not specified, defaults to true. Providing non-boolean values will result in a 400 error.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <href>https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-:bucketKey-objects-:objectKey-batchsigneds3upload-POST/</href>
		/// <returns>Task of ApiResponse (dynamic)</returns>
		public async System.Threading.Tasks.Task<ApiResponse<dynamic>> getS3UploadURLsAsyncWithHttpInfo (string bucketKey, PostBatchSignedS3UploadPayload body, Dictionary<string, object> opts = null) {
			// verify the required parameter 'bucketKey' is set
			if ( String.IsNullOrEmpty (bucketKey) )
				throw new ApiException (400, "Missing the required parameter 'bucketKey' when calling getS3UploadURLsAsyncWithHttpInfo");
			// verify the required parameter 'body' is set
			if ( body == null )
				throw new ApiException (400, "Missing the required parameter 'body' when calling getS3UploadURLsAsyncWithHttpInfo");
			if ( body.requests == null || body.requests.Count == 0 )
				throw new ApiException (400, "Missing the required parameter 'body.requests' when calling getS3UploadURLsAsyncWithHttpInfo");
			for ( int i = 0 ; i < body.requests.Count ; i++ ) {
				if ( String.IsNullOrEmpty (body.requests [i].objectKey) )
					throw new ApiException (400, "Missing the required parameter 'body.requests[].objectKey' when calling getS3UploadURLsAsyncWithHttpInfo");
			}

			var localVarPath = "/oss/v2/buckets/{bucketKey}/objects/batchsigneds3upload";
			var localVarPathParams = new Dictionary<string, string> ();
			localVarPathParams.Add ("bucketKey", Configuration.ApiClient.ParameterToString (bucketKey)); // path parameter
			var localVarQueryParams = Opts2Dictionary (
				opts,
				new Dictionary<string, string> () {
					{ "useAcceleration", "useAcceleration" },
					{ "minutesExpiration", "minutesExpiration" }
				}
			);
			var localVarHeaderParams = new Dictionary<string, string> (Configuration.DefaultHeader);
			var localVarFormParams = new Dictionary<string, string> ();
			var localVarFileParams = new Dictionary<String, FileParameter> ();
			Object localVarPostBody = body;

			// to determine the Content-Type header
			String [] localVarHttpContentTypes = new String [] {
				"application/json"
			};
			String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType (localVarHttpContentTypes);

			// to determine the Accept header
			String [] localVarHttpHeaderAccepts = new String [] {
				"application/vnd.api+json",
				"application/json"
			};
			String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept (localVarHttpHeaderAccepts);
			if ( !String.IsNullOrEmpty (localVarHttpHeaderAccept) )
				localVarHeaderParams.Add ("Accept", localVarHttpHeaderAccept);

			// authentication (oauth2_application) required
			// oauth required
			if ( !String.IsNullOrEmpty (Configuration.AccessToken) )
				localVarHeaderParams ["Authorization"] = "Bearer " + Configuration.AccessToken;

			// make the HTTP request
			RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync (
				localVarPath, Method.Post,
				localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
				localVarPathParams, localVarHttpContentType
			);

			int localVarStatusCode = (int)localVarResponse.StatusCode;

			if ( ExceptionFactory != null ) {
				Exception exception = ExceptionFactory ("getS3UploadURLsAsyncWithHttpInfo", localVarResponse);
				if ( exception != null )
					throw exception;
			}

			return (new ApiResponse<dynamic> (
				localVarStatusCode,
				localVarResponse.Headers.ToDictionary (x => x.Name, x => x.Value.ToString ()),
				Configuration.ApiClient.Deserialize (localVarResponse, null)
			));
		}

		// Workflow implementations

		/// <summary>Download a resource.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objects">{Object|Object[]} Object or Object array of resource to uplaod with their parameters</param>
		/// <param name="object[].objectKey">{String} object key</param>
		/// <param name="object[].responseType">{String} Resource to upload
		/// If String, it is the expected response type (defaults to json) ['arraybuffer', 'document', 'json', 'text', 'stream']
		/// If you 'stream', you need to provide a writable stream ('data'), the method will pipe content into it.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.publicResourceFallback">{Boolean=false} Allows fallback to OSS signed URLs in case of unmerged resumable uploads.</param>
		/// <param name="opts.useCdn">{Boolean=true} Will generate a CloudFront URL for the S3 object.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <param name="opts.chunkSize">{Integer=0} Chunk size in Mb. Should not be below 5Mb. Default is 0, download file in one piece.</param>
		/// <param name="onDownloadProgress">{DownloadItemsCallBack} (progressEvent) => {}</param>
		/// <param name="onRefreshToken">{RefreshTokenCallBack} () => {}</param>
		/// <returns>Task of ApiResponse (dynamic[])</returns>
		public async System.Threading.Tasks.Task<List<DownloadItemDesc>> downloadResources (string bucketKey, List<DownloadItemDesc> objects, Dictionary<string, object> opts = null, DownloadItemsCallBack onDownloadProgress = null, RefreshTokenCallBack onRefreshToken = null) {
			if ( String.IsNullOrEmpty (bucketKey) )
				throw new ApiException (400, "Missing the required parameter 'bucketKey' when calling downloadResources");
			if ( objects == null )
				throw new ApiException (400, "Missing the required parameter 'objects' when calling downloadResources");
			for ( int i = 0 ; i < objects.Count ; i++ ) {
				if ( String.IsNullOrEmpty (objects [i].objectKey) )
					throw new ApiException (400, "Missing the required parameter 'objects[].objectKey' when calling downloadResources");
				if ( String.IsNullOrEmpty (objects [i].responseType) )
					throw new ApiException (400, "Missing the required parameter 'objects[].responseType' when calling downloadResources");
				//if ( objects [i].responseType == "stream" && (objects [i].data == null || objects [i].data.CanWrite == false) )
				//	throw new ApiException (400, "Missing the required parameter 'objects[].data' when calling downloadResources with responseType == 'stream'");
			}
			if ( opts == null )
				opts = new Dictionary<string, object> ();
			var _this = this;

			async System.Threading.Tasks.Task<long> requestSize (string _bucketKey, List<DownloadItemDesc> _objects) {
				try {
					if ( _this.Configuration.Bearer.isAboutToExpire () && onRefreshToken != null ) {
						Bearer bearer = await onRefreshToken ();
						if ( bearer != null )
							_this.Configuration.Bearer = bearer;
					}
					PostBatchSignedS3DownloadPayload payload = new PostBatchSignedS3DownloadPayload ();
					foreach ( DownloadItemDesc entry in _objects )
						payload.requests.Add (new PostBatchSignedS3DownloadPayloadItem (entry.objectKey));
					dynamic downloadParams = await _this.getS3DownloadURLsAsync (
						_bucketKey,
						payload,
						opts
					); // Automatically retries 429 and 500-599 responses

					DynamicDictionary results = downloadParams ["results"];
					//long size = 0;
					//foreach ( var item in results.Items () ) {
					//	var tt = item.Value as dynamic;
					//	var gg = tt ["size"];
					//	if ( tt ["status"] == "complete" )
					//		size += tt ["size"];
					//}
					long size = results.Items ().Sum (x => (x.Value as dynamic) ["status"] == "complete" ? (long)((x.Value as dynamic) ["size"]) : 0);
					return (size);
				} catch ( Exception ex ) {
					Debug.WriteLine (ex.Message);
				}
				return (0);
			}

			async System.Threading.Tasks.Task<DownloadItemDesc> requestURL (string _bucketKey, DownloadItemDesc record) {
				try {
					if ( _this.Configuration.Bearer.isAboutToExpire () && onRefreshToken != null ) {
						Bearer bearer = await onRefreshToken ();
						if ( bearer != null )
							_this.Configuration.Bearer = bearer;
					}
					record.downloadParams = await _this.getS3DownloadURLsAsync (
						_bucketKey,
						new PostBatchSignedS3DownloadPayload (
							new PostBatchSignedS3DownloadPayloadItem (record.objectKey, "application/octet-stream")
						),
						opts
					); // Automatically retries 429 and 500-599 responses
					if ( record.downloadParams ["results"] [record.objectKey] ["status"] == "complete" )
						record.downloadUrl = record.downloadParams ["results"] [record.objectKey] ["url"];
					else
						record.Error = true;
				} catch ( Exception ex ) {
					record.Error = true;
					record.download = ex;
				}
				return (record);
			}

			async System.Threading.Tasks.Task<DownloadItemDesc> downloadData (DownloadItemDesc record) {
				try {
					if ( record.Error || String.IsNullOrEmpty (record.downloadUrl) )
						return (null);
					
					// `responseType` indicates the type of data that the server will respond with
					// options are: 'arraybuffer', 'json', 'text', 'stream' (default json)
					// 'stream' with response.data.pipe(__fs.createWriteStream('...'))

					string responseType = "json";
					if ( record.isStream )
						responseType = "stream";
					else if ( !String.IsNullOrEmpty (record.responseType) )
						responseType = record.responseType;

					//HttpRequestMessage request = new HttpRequestMessage (HttpMethod.Get, record.downloadUrl);
					//request.Headers
					//	Object.keys (record).map ((key) => {
					//		if ( key.startsWith ('response-') )
					//			headers [key.substring (9)] = record [key];
					//	});
					//await httpClient.SendAsync (request);

					HttpClient httpClient = new HttpClient ();
					//HttpResponseMessage response = await httpClient.GetAsync (record.downloadUrl);
					HttpRequestMessage request = new HttpRequestMessage {
						RequestUri = new Uri (record.downloadUrl),
						Method = HttpMethod.Get
					};
					if ( record.headers != null && record.headers.ContainsKey ("Range") == true )
						request.Headers.Range = record.headers ["Range"] as RangeHeaderValue;
					HttpResponseMessage response = await httpClient.SendAsync (request);

					if ( response.StatusCode == System.Net.HttpStatusCode.Forbidden ) {
						record.downloadUrl = null;
						return (null);
					} else if ( response.StatusCode == System.Net.HttpStatusCode.OK || (record.headers != null && record.headers.ContainsKey ("Range") == true && response.StatusCode == System.Net.HttpStatusCode.PartialContent) ) {
					} else {
						throw new ApiException (400, "Unexpected value");
					}

					switch ( responseType ) {
						case "arraybuffer":
							record.data = await response.Content.ReadAsByteArrayAsync ();
							break;
						case "json":
							record.data = await response.Content.ReadAsStringAsync ();
							record.data = JObject.Parse (record.data);
							break;
						case "text":
							record.data = await response.Content.ReadAsStringAsync ();
							break;
						case "stream":
							Stream temp = await response.Content.ReadAsStreamAsync ();
							if ( record.data == null ) {
								record.data = temp;
							} else {
								temp.Position = 0;
								await temp.CopyToAsync (record.data);
							}
							break;
					}

					return (record);
				} catch ( Exception err ) {
					record.Error = true;
					record.download = err;
				}
				return (null);
			}

			DateTime startTS = DateTime.Now;
			if ( onDownloadProgress != null )
				onDownloadProgress (0f, TimeSpan.Zero, objects);
			long totalSize = await requestSize (bucketKey, objects);
			long dataRead = 0;
			long ChunkSize = opts.ContainsKey ("chunkSize") ? (int)opts ["chunkSize"] << 20 : 5 << 20;
			for ( int entry = 0 ; entry < objects.Count ; entry++ ) {
				DownloadItemDesc record = objects [entry];
			
				await requestURL (bucketKey, record);
				await downloadData (record);

				dataRead += record.downloadParams ["results"] [record.objectKey] ["size"];
				record.Progress = 1.0f;
				if ( onDownloadProgress != null )
					onDownloadProgress (1.0f * dataRead / totalSize, DateTime.Now - startTS, objects);
			}
			if ( onDownloadProgress != null )
				onDownloadProgress (1f, DateTime.Now - startTS, objects);
			return (objects);
		}

		/// <summary>Upload a resource. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination.</summary>
		/// <param name="bucketKey">{String} bucket key (will be URL-encoded automatically)</param>
		/// <param name="objects">{Object|Object[]} Object or Object array of resource to upload with their parameters</param>
		/// <param name="object[].objectKey">{String} object key</param>
		/// <param name="object[].data">{String|Buffer|Stream} Resource to upload (String| Buffer | Stream)</param>
		/// <param name="object[].eTags">{String[]=} An array of eTags. S3 returns an eTag to each upload request, be it for a chunk or an entire file.
		/// For a single-part upload, this array contains the expected eTag of the entire object. For a multipart upload, this array contains the expected 
		/// eTag of each part of the upload; the index of an eTag in the array corresponds to its part number in the upload. If provided, OSS will validate 
		/// these eTags against the content in S3, and return an error if the eTags do not match (indicating some form of data corruption).</param>
		/// <param name="object[].xAdsMetaContentType">{String=} (x-ads-meta-Content-Type) The Content-Type value that OSS will store in the record for the uploaded object.</param>
		/// <param name="object[].xAdsMetaContentDisposition">{String=} (x-ads-meta-Content-Disposition) The Content-Disposition value that OSS will store in the record for the uploaded object.</param>
		/// <param name="object[].xAdsMetaContentEncoding">{String=} (x-ads-meta-Content-Encoding) The Content-Encoding value that OSS will store in the record for the uploaded object.</param>
		/// <param name="object[].xAdsMetaCacheControl">{String=} (x-ads-meta-Cache-Control) The Cache-Control value that OSS will store in the record for the uploaded object.</param>
		/// <param name="opts">{Object=} Optional parameters</param>
		/// <param name="opts.chunkSize">{Integer=5} Chunk size in Mb. Should not be below 5Mb.</param>
		/// <param name="opts.maxBatches">{Integer=25} Maximum batch to produces. Should not be above 25 or below 1.</param>
		/// <param name="opts.useAcceleration">{Boolean=true} Whether or not to generate an accelerated signed URL (ie: URLs of 
		/// the form …s3-accelerate.amazonaws.com… vs …s3.amazonaws.com…).
		/// When not specified, defaults to true. Providing non-boolean values will result in a 400 error.</param>
		/// <param name="opts.minutesExpiration">{Integer=2} The custom expiration time within the 1 to 60 minutes range, if not specified, default is 2 minutes.</param>
		/// <param name="onDownloadProgress">{DownloadItemsCallBack} (progressEvent) => {}</param>
		/// <param name="onRefreshToken">{RefreshTokenCallBack} () => {}</param>
		/// <returns>Task of ApiResponse (dynamic[])</returns>
		public async System.Threading.Tasks.Task<List<UploadItemDesc>> uploadResources (string bucketKey, List<UploadItemDesc> objects, Dictionary<string, object> opts = null, UploadItemsCallBack onUploadProgress = null, RefreshTokenCallBack onRefreshToken = null) {
			if ( String.IsNullOrEmpty (bucketKey) )
				throw new ApiException (400, "Missing the required parameter 'bucketKey' when calling uploadResources");
			if ( objects == null )
				throw new ApiException (400, "Missing the required parameter 'objects' when calling uploadResources");
			for ( int i = 0 ; i < objects.Count ; i++ ) {
				if ( String.IsNullOrEmpty (objects [i].objectKey) )
					throw new ApiException (400, "Missing the required parameter 'objects[].objectKey' when calling downloadResources");
				if ( objects [i].data == null )
					throw new ApiException (400, "Missing the required parameter 'objects[].data' when calling uploadResources");
			}
			if ( opts == null )
				opts = new Dictionary<string, object> ();
			var _this = this;

			if ( opts != null && opts.ContainsKey ("chunkSize") && (int)opts ["chunkSize"] < 5 )
				throw new ApiException (400, "Required parameter 'opts.chunkSize' should be >= 5 when calling uploadResources");
			if ( opts != null && opts.ContainsKey ("maxBatches") && ((int)opts ["maxBatches"] < 1 || (int)opts ["maxBatches"] > 25) )
				throw new ApiException (400, "Required parameter 'opts.maxBatches' should be >= 1 and <= 25 when calling uploadResources");

			async System.Threading.Tasks.Task<UploadItemDesc> requestURLs (string _bucketKey, UploadItemDesc record, int firstPart, int parts) {
				try {
					if ( _this.Configuration.Bearer.isAboutToExpire () && onRefreshToken != null ) {
						Bearer bearer = await onRefreshToken ();
						if ( bearer != null )
							_this.Configuration.Bearer = bearer;
					}
					dynamic uploadParams = await _this.getS3UploadURLsAsync (
						_bucketKey,
						new PostBatchSignedS3UploadPayload (
							new PostBatchSignedS3UploadPayloadItem (record.objectKey, firstPart, parts, record.uploadKey)
						),
						opts
					); // Automatically retries 429 and 500-599 responses

					DynamicDictionary test = uploadParams ["results"] [record.objectKey] ["urls"];
					record.uploadUrls = test.Items ().Select (x => (string)x.Value).ToList<string> ();
					if ( record.uploadKey == null )
						record.uploadKey = uploadParams ["results"] [record.objectKey] ["uploadKey"];
				} catch ( Exception ex ) {
					record.Error = true;
					record.uploads = ex;
				}
				return (record);
			}

			async System.Threading.Tasks.Task<dynamic> completeObjects (string _bucketKey, UploadItemDesc record) {
				try {
					if ( _this.Configuration.Bearer.isAboutToExpire () && onRefreshToken != null ) {
						Bearer bearer = await onRefreshToken ();
						if ( bearer != null )
							_this.Configuration.Bearer = bearer;
					}
					record.completedResponse = await _this.completeS3UploadsAsync (
						_bucketKey,
						new PostBatchCompleteS3UploadPayload (
							new PostBatchCompleteS3UploadPayloadItem (
								record.objectKey,
								record.uploadKey,
								record.Length,
								record.eTags,
								record.xAdsMetaContentType,
								record.xAdsMetaContentDisposition,
								record.xAdsMetaContentEncoding,
								record.xAdsMetaCacheControl
							)
						),
						opts
					);
					record.chunk = null;
					record.uploadUrls = null;
					record.completed = record.completedResponse ["results"] [record.objectKey];
					if ( record.completed.ContainsKey ("status") && record.completed ["status"] == "error" )
						record.Error = true;
				} catch ( Exception ex ) {
					record.Error = true;
					record.completed = ex;
				}
				return (record);
			}

			async System.Threading.Tasks.Task<UploadItemDesc> uploadData (string url, UploadItemDesc record, TimeSpan _timeOut) {
				try {
					// `responseType` indicates the type of data that the server will respond with
					// options are: 'arraybuffer', 'document', 'json', 'text', 'stream' (default json)

					HttpClient httpClient = new HttpClient ();
					httpClient.Timeout = _timeOut;
					Stream memStream = new MemoryStream (record.chunk);
					StreamContent streamContent = new StreamContent (memStream);
					HttpResponseMessage response = await httpClient.PutAsync (url, streamContent);
					if ( response.StatusCode == System.Net.HttpStatusCode.Forbidden ) {
						record.uploadUrls = new List<string> ();
						return (null);
					} else if ( response.StatusCode == System.Net.HttpStatusCode.OK ) {
						record.eTags.Add (response.Headers.ETag.Tag.Trim(new char [] { '\"' }));
					} else {
						throw new ApiException (400, "Unexpected value");
					}

					return (record);
				} catch ( Exception err ) {
					throw err;
				}
				//return (null);
			}

			async System.Threading.Tasks.Task processChunk (string _bucketKey, UploadItemDesc record, long partsUploaded, long totalParts, long _MaxBatches, TimeSpan _timeOut) {
				while ( true ) {
					Debug.WriteLine ("Uploading part {0} {1} {2}/{3}", _bucketKey, record.objectKey, partsUploaded + 1, '/', totalParts);
					if ( record.uploadUrls == null || record.uploadUrls.Count == 0 )
						await requestURLs (_bucketKey, record, (int)partsUploaded + 1, (int)Math.Min (totalParts - partsUploaded, _MaxBatches));

					string url = record.uploadUrls [0];
					record.uploadUrls.RemoveAt (0);
					dynamic res = await uploadData (url, record, _timeOut);
					if ( res != null )
						break;
				}
			}

			DateTime startTS = DateTime.Now;
			long totalSize = objects.Sum (f => f.Length);
			long dataSent = 0;
			long ChunkSize = opts.ContainsKey ("chunkSize") ? (int)opts ["chunkSize"] << 20 : 5 << 20;
			long MaxBatches = opts.ContainsKey ("maxBatches") ? (int)opts ["maxBatches"] : 25;
			if ( onUploadProgress != null )
				onUploadProgress (0f, TimeSpan.Zero, objects);
			TimeSpan timeOut = opts.ContainsKey ("TimeOut") ? (TimeSpan)opts ["TimeOut"] : TimeSpan.FromSeconds (100);
			for ( int entry = 0 ; entry < objects.Count ; entry++ ) {
				UploadItemDesc record = objects [entry];
				if ( record.isStream && record.Length == 0 )
					throw new ApiException (400, "Missing parameter length for a stream object");
				long totalParts = (int)Math.Ceiling ((decimal)record.Length / ChunkSize);
				record.eTags = new List<string> ((int)totalParts);
				long partsUploaded = 0;
				if ( record.isStream ) {
					while ( partsUploaded < totalParts ) {
						//record.chunk = record.data;
						long chunkSize = Math.Min ((partsUploaded + 1) * ChunkSize, record.Length) - partsUploaded * ChunkSize;
						Stream readStream = record.data;
						record.chunk = new byte [chunkSize];
						await readStream.ReadAsync (record.chunk, 0, (int)chunkSize);
						await processChunk (bucketKey, record, partsUploaded, totalParts, MaxBatches, timeOut);
						dataSent += chunkSize;
						Debug.WriteLine ("Part successfully uploaded {0}", partsUploaded + 1);
						partsUploaded++;
						record.Progress = 1.0f * partsUploaded / totalParts;
						if ( onUploadProgress != null )
							onUploadProgress (1.0f * dataSent / totalSize, DateTime.Now - startTS, objects);
					}
				} else {
					while ( partsUploaded < totalParts ) {
						//record.chunk = record.data;
						long chunkSize = Math.Min ((partsUploaded + 1) * ChunkSize, record.Length) - partsUploaded * ChunkSize;
						record.chunk = record.Chunk (partsUploaded * ChunkSize, chunkSize);
						await processChunk (bucketKey, record, partsUploaded, totalParts, MaxBatches, timeOut);
						dataSent += chunkSize;
						Debug.WriteLine ("Part successfully uploaded {0}", partsUploaded + 1);
						partsUploaded++;
						record.Progress = 1.0f * partsUploaded / totalParts;
						if ( onUploadProgress != null )
							onUploadProgress (1.0f * dataSent / totalSize, DateTime.Now - startTS, objects);
					}
				}
				Debug.WriteLine ("Completing parts upload");
				await completeObjects (bucketKey, record);
			}
			if ( onUploadProgress != null )
				onUploadProgress (1.0f, DateTime.Now - startTS, objects);
			return (objects);
		}

		// Workflow implementations

		#endregion

		public static string calculateSHA1 (string input) {
			using ( SHA1 sha1Hash = SHA1.Create () ) {
				byte [] sourceBytes = System.Text.Encoding.UTF8.GetBytes (input);
				byte [] hashBytes = sha1Hash.ComputeHash (sourceBytes);
				string hash = BitConverter.ToString (hashBytes).Replace ("-", String.Empty).ToLower ();
				return (hash);
			}
		}

		public static string calculateSHA1 (System.IO.Stream input) {
			input.Seek (0, SeekOrigin.Begin);
			using ( SHA1 sha1Hash = SHA1.Create () ) {
				byte [] hashBytes = sha1Hash.ComputeHash (input);
				string hash = BitConverter.ToString (hashBytes).Replace ("-", String.Empty).ToLower ();
				return (hash);
			}
		}

		public static string calculateSHA1 (byte [] input) {
			using ( SHA1 sha1Hash = SHA1.Create () ) {
				byte [] hashBytes = sha1Hash.ComputeHash (input);
				string hash = BitConverter.ToString (hashBytes).Replace ("-", String.Empty).ToLower();
				return (hash);
			}
		}

	}
}
